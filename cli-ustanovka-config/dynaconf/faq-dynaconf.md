# FAQ dynaconf

Вот несколько вопросов об использовании Dynaconf.

* Чтобы получить дополнительную помощь, воспользуйтесь [обсуждениями на GitHub](https://github.com/dynaconf/dynaconf/issues).
* Если вы хотите предложить здесь несколько новых вопросов, используйте [проблемы GitHub](https://github.com/dynaconf/dynaconf/discussions).

## Динамически устанавливать путь `settings_path`

> У меня несколько сред, и я не хочу полагаться на определенное расположение файла настроек. Как мне установить его путь динамически?

[Параметры конфигурации, специфичные для Dynaconf](konfiguraciya-dynaconf.md), такие как **settings\_file** или **settings\_files**, имеют два способа определения:

* Параметры экземпляра: `Dynaconf(settings_file="path.to.settings.toml")`
* В параметрах среды: `export SETTINGS_FILE_FOR_DYNACONF="path.to.settings"`

Итак, для каждой среды просто экспортируйте правильный путь. Обратите внимание, что он должен быть ПРОПИСНЫМ и иметь суффикс **\_FOR\_DYNACONF**.

Настройки среды по умолчанию переопределяют настройки экземпляра.

## Проблема с запуском тестов в IDE

> Я пытаюсь запустить тест в своей IDE, но возникает исключение `OSError: Starting path not found`, хотя запуск из CLI работает нормально. Что это может быть?

Разрешение пути Dynaconf зависит от того, находится ли ваш **CWD** (current working directory - текущий рабочий каталог) в корне проекта. Некоторые IDE могут модифицировать **CWD** для запуска тестов, и это может вызвать эту проблему.

**PyCharm**, например, может изменить **CWD** на `./tests` в своей интегрированной системе тестирования. Если это ваш конкретный случай, перейдите в `"Modify Run Configuration > Working Dir"` на вкладке `"Test"` и убедитесь, что он указывает на корень вашего проекта.

## Условная проверка

> Можно ли создать валидатор, который бы требовал наличия опции, если присутствует другая опция?

Да. Валидаторы обеспечивают большую гибкость в способах их организации. Если **foo** должен присутствовать только в том случае, если существует **bar**, вы можете сделать:

```python
Validator(
        "foo",
        must_exist=True,
        when=Validator(
            "bar", must_exist=True,
        ),
    ),
```

Подробнее о [валидаторах](validaciya-v-dynaconf.md)

## Механизм устаревания

> У меня довольно загруженный проект, и иногда ему мешают старые конфигурационные файлы. Существует ли механизм устаревания для решения этой проблемы?

Уже есть [запрос на более конкретный механизм](https://github.com/dynaconf/dynaconf/discussions/881) прекращения поддержки, но прямо сейчас вы можете использовать для этого перехваты (хуки). Вы можете сделать что-то вроде:

```python
# dynaconf_hooks.py
def post(settings: Dynaconf) -> dict:
    DEPRECATED = {
        "FOO": "NEWKEY"
    }
    for key, new in DEPRECATED.items():
        if value := settings.get(key):
            warnings.warn(f"{key} has been replaced by {new}")
            settings.set(new, value)
```

Подробнее о [хуках](rasshirennoe-ispolzovanie-dynaconf.md#khuki)

## Функции Django внутри настроек

> Я использую некоторые служебные функции django в своем файле `settings.py` django. Могу ли я по-прежнему использовать их, если решу использовать **yaml** для управления своей конфигурацией?

Да, вы можете добавить собственный конвертер для любых функций, которые вам нравятся. Полный пример см. [здесь](django-i-dynaconf.md#ispolzuite-funkcii-django-vnutri-polzovatelskikh-nastroek).

## Рабочий процесс с переопределением по умолчанию

> Я хотел бы использовать базовый файл в качестве настроек по умолчанию (например, django `settings.py`) и настройки пользовательского файла, куда я бы более явно добавил свои собственные переопределения. Можно ли это сделать?

Да, это вполне возможно. По умолчанию настройки верхнего уровня с разными ключами будут сохранены, а настройки с одинаковыми ключами будут переопределены.

```python
# settingsA.yaml
name="John"

# settingsB.yaml
age=23

# resultant
name="John"
age=23
```

Обратите внимание, что это также переопределит целые вложенные структуры (например, списки или словари).

```python
# settingsA.yaml
bucket=[1,2,3,4]

# settingsB.yaml
bucket=["a", "b", "c", "d"]

# resultant (default)
bucket=["a", "b", "c", "d"]
```

Чтобы контролировать, как вы хотите объединить эти структуры, вы можете взглянуть на [слияние (merging)](sliyanie-merging.md). Существует несколько способов объединения данных: настройка глобального параметра [merge\_enabled](konfiguraciya-dynaconf.md#merge\_enabled), использование синтаксиса **dunder** или маркировка всего файла, определенного окружения или просто вариант слияния. Выбирайте то, что лучше всего подходит для вашего случая.

## Ошибка с исполняемым файлом Pyinstaller

> У меня возникли проблемы с запуском исполняемого приложения, использующего Dynaconf. Что бы это могло быть?

[Пользователь сообщил об этой ситуации](https://github.com/dynaconf/dynaconf/issues/770) при использовании **Pyinstaller**. В его случае исправлением было упаковать **dynaconf** и **python-dotenv\[cli]** без компиляции с использованием аргумента `--collect-all` **pyinstaller**.

## Экземпляр Dynaconf из словаря

> Я хотел бы, чтобы объект Dynaconf был создан из словаря Python, но при этом можно было бы использовать на нем валидаторы. Является ли это возможным?

Да, это возможно.

Допустим, вы получили строковый json непосредственно из API и хотите интегрировать его в объект Dynaconf, используя некоторую проверку. Вы можете сделать это:

```python
data = get_data_as_dict()

settings = Dynaconf()

settings.validators.register(Validator("aws", "elasticsearch", must_exist=True))
settings.update(data)
settings.validators.validate()
```
