# Обнаружение пакета и доступ к ресурсам с pkg\_resources

Модуль pkg\_resources, распространяемый вместе с setuptools, предоставляет API для библиотек Python для доступа к их файлам ресурсов, а также для расширяемых приложений и платформ для автоматического обнаружения плагинов. Он также обеспечивает поддержку во время выполнения использования расширений C, находящихся внутри eggs-формата zip-файла, поддержку объединения пакетов, имеющих отдельно распространяемые модули или подпакеты, а также API для управления текущим «рабочим набором» активных пакетов Python.

{% hint style="danger" %}
Использование pkg\_resources устарело в пользу [importlib.resources](https://docs.python.org/3.11/library/importlib.resources.html#module-importlib.resources), [importlib.metadata](https://docs.python.org/3.11/library/importlib.metadata.html#module-importlib.metadata) и их бэкпортов ([importlib\_resources](https://pypi.org/project/importlib\_resources), [importlib\_metadata](https://pypi.org/project/importlib\_metadata)). Некоторые полезные API также предоставляются [packaging](https://pypi.org/project/packaging) (например, требования requirements и анализ версий). Пользователям следует воздерживаться от нового использования pkg\_resources и работать над портированием решений на основе importlib.
{% endhint %}

## Обзор

Модуль pkg\_resources предоставляет средства выполнения для поиска, анализа, активации и использования установленных дистрибутивов Python. Некоторые из более продвинутых функций (в частности, поддержка параллельной установки нескольких версий) основаны конкретно на формате "egg" (либо в виде zip-архива, либо в подкаталоге), в то время как другие (например, обнаружение плагинов) будут работать правильно, пока каталоги метаданных "egg-info" доступны для соответствующих дистрибутивов.

Eggs — это формат распространения модулей Python, по своей концепции схожий с "jars" Java или "gems" Ruby или форматом "wheel", определенным в PEP 427. Однако, в отличие от чистого формата распространения, eggs также можно устанавливать и добавлять напрямую в sys.path в качестве места импорта. При такой установке eggs доступны для обнаружения, а это означает, что они содержат метаданные, которые однозначно идентифицируют их содержимое и зависимости. Это означает, что установленное egg может быть автоматически найдено и добавлено в sys.path в ответ на простые запросы вида «принеси мне все, что мне нужно, чтобы использовать поддержку PDF в документах». Эта функция позволяет взаимно конфликтующим версиям дистрибутива сосуществовать в одной и той же установке Python, при этом отдельные приложения активируют нужную версию во время выполнения, манипулируя содержимым sys.path (это отличается от подхода к виртуальной среде, который предполагает создание изолированных сред для каждого приложения).

Для объяснения возможностей, предлагаемых этим модулем, необходимы следующие термины:

* project - Библиотека, платформа, скрипт, плагин, приложение или набор данных или других ресурсов или некоторая их комбинация. Предполагается, что проекты имеют «относительно уникальные» имена, например, имена, зарегистрированные с помощью PyPI.
* release - Снимок проекта в определенный момент времени, обозначаемый идентификатором версии.
* distribution - Файл или файлы, представляющие конкретный выпуск.
* importable distribution - Файл или каталог, который, если он помещен в sys.path, позволяет Python импортировать любые содержащиеся в нем модули.
* pluggable distribution - Импортируемый дистрибутив, имя файла которого однозначно идентифицирует его выпуск (т. е. проект и версию), а содержимое которого однозначно указывает, какие выпуски других проектов будут удовлетворять его требованиям времени выполнения.
* extra - это необязательная функция выпуска, которая может налагать дополнительные требования к времени выполнения. Например, если для поддержки PDF в docutils требуется наличие библиотеки поддержки PDF, docutils может определить поддержку PDF как дополнительную "extra" и перечислить, какие другие версии проекта должны быть доступны, чтобы ее обеспечить.
* environment - Коллекция дистрибутивов, потенциально доступных для импорта, но не обязательно активных. В среде может присутствовать более одного дистрибутива (т.е. версии выпуска) для данного проекта.
* working set - Коллекция дистрибутивов, фактически доступных для импорта, как в sys.path. В рабочем наборе может присутствовать не более одного дистрибутива (релизной версии) данного проекта, иначе возникнет неясность относительно того, что импортировать.
* eggs - это подключаемые дистрибутивы в одном из трех форматов, поддерживаемых в настоящее время pkg\_resources. Существуют built eggs, developmant eggs и eggs links. Built eggs — это каталоги или zip-файлы, имена которых заканчиваются на .egg и соответствуют соглашениям об именах eggs, и содержат подкаталог EGG-INFO (заархивированный или другой). Developmant eggs — это обычные каталоги кода Python с одним или несколькими подкаталогами ProjectName.egg-info. Формат developmant eggs также используется для предоставления версии дистрибутива по умолчанию, доступной программному обеспечению, которое не использует pkg\_resources для запроса определенных версий. Eggs links — это файлы \*.egg-link, которые содержат имя built или developmant egg для поддержки символических ссылок на платформах, которые не имеют собственных символических ссылок (или где поддержка символических ссылок ограничена).

Для получения дополнительной информации об этих терминах и концепциях см. также этот [архитектурный обзор](https://mail.python.org/pipermail/distutils-sig/2005-June/004652.html) pkg\_resources и Python Eggs в целом.

## Справочник по API

### Поддержка пакетов пространства имен

Пакет пространства имен — это пакет, который содержит только другие пакеты и модули и не имеет собственного содержимого. Такие пакеты можно разделить на несколько отдельно упакованных дистрибутивов. Обычно они используются для разделения больших пакетов, созданных одной организацией, например, в пакете пространства имен zope для пакетов Zope Corporation и в пакете пространства имен peak для Python Enterprise Application Kit.

Чтобы создать пакет пространства имен, вы указываете его в аргументе namespace\_packages функции setup() в файле setup.py вашего проекта. (Дополнительную информацию об этом см. в [документации по setuptools для пакетов пространства имен](rukovodstvo-polzovatelya-setuptools/obnaruzhenie-paketov-i-pakety-prostranstva-imen.md#poisk-paketov-prostranstva-imen)). Кроме того, необходимо добавить вызов declare\_namespace() в файл(ы) `__init__.py` пакета:

* declare\_namespace(name) - Объявляет, что имя пакета, разделенное точками, является «пакетом пространства имен», содержащиеся в нем пакеты и модули могут быть распределены по нескольким дистрибутивам. `__path__` именованного пакета будет расширен за счет включения соответствующего пакета во все дистрибутивы на sys.path, содержащие пакет с таким именем. (Точнее, если find\_module(name) импортера возвращает загрузчик, то он также будет искать содержимое пакета.) Всякий раз, когда вызывается метод active() дистрибутива, он проверяет наличие пакетов пространства имен и обновляет их содержимое `__path__` соответственно.

Приложениям, которые манипулируют пакетами пространства имен или напрямую изменяют sys.path во время выполнения, также может потребоваться использовать эту функцию API:

* fixup\_namespace\_packages(path\_item) - Объявляет, что path\_item — это новый элемент, добавленный в sys.path, который, возможно, потребуется использовать для обновления существующих пакетов пространства имен. Обычно это вызывается для вас, когда egg автоматически добавляется в sys.path, но если ваше приложение изменяет sys.path, чтобы включить местоположения, которые могут содержать части пакета пространства имен, вам нужно будет вызвать эту функцию, чтобы убедиться, что они добавлены. к существующим пакетам пространства имен.

Хотя по умолчанию pkg\_resources поддерживает только пакеты пространства имен для импортеров файловой системы и zip, вы можете расширить его поддержку для других «импортеров», совместимых с PEP 302, с помощью функции register\_namespace\_handler(). Подробности см. в разделе ниже «[Поддержка пользовательских импортеров](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#podderzhka-polzovatelskikh-importerov)».

### Объекты WorkingSet

Класс WorkingSet предоставляет доступ к коллекции «активных» дистрибутивов. В общем, существует только один значимый экземпляр рабочего набора: тот, который представляет дистрибутивы, которые в данный момент активны в sys.path. Этот глобальный экземпляр доступен под именем working\_set в модуле pkg\_resources. Однако специализированные инструменты могут захотеть манипулировать рабочими наборами, которые не соответствуют sys.path, и, следовательно, могут захотеть создать другие экземпляры WorkingSet.

Важно отметить, что глобальный объект working\_set инициализируется из sys.path при первом импорте pkg\_resources, но обновляется только в том случае, если вы выполняете все будущие манипуляции с sys.path через API pkg\_resources. Если вы вручную изменяете sys.path, вам необходимо вызвать соответствующие методы экземпляра working\_set, чтобы обеспечить его синхронизацию. К сожалению, Python не предоставляет никакого способа обнаружить произвольные изменения в объекте списка, таком как sys.path, поэтому pkg\_resources не может автоматически обновлять working\_set на основе изменений в sys.path.

* WorkingSet(entries=None) - Создает WorkingSet из итерации записей пути. Если entries не указаны, по умолчанию используется значение sys.path во время вызова конструктора. Обратите внимание, что обычно вы не создаете экземпляры WorkingSet самостоятельно, а вместо этого явно или неявно используете глобальный экземпляр working\_set. По большей части API pkg\_resources спроектирован так, что по умолчанию используется working\_set, так что вам не придется большую часть времени явно ссылаться на него.

Все дистрибутивы, доступные непосредственно в sys.path, будут активированы автоматически при импорте pkg\_resources. Такое поведение может вызвать конфликты версий для приложений, которым требуются версии этих дистрибутивов, отличные от версий по умолчанию. Чтобы справиться с этой ситуацией, pkg\_resources проверяет наличие атрибута `__requires__` в модуле `__main__` при инициализации рабочего набора по умолчанию и использует его, чтобы убедиться, что активирована подходящая версия каждого затронутого дистрибутива. Например:

```python
 # Должен быть установлен перед импортом pkg_resources
__requires__ = ["CherryPy < 3"]
import pkg_resources
```

### Базовые методы WorkingSet

### Поддержка пользовательских импортеров
