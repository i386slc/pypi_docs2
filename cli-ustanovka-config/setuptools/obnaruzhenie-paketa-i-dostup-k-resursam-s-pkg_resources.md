# Обнаружение пакета и доступ к ресурсам с pkg\_resources

Модуль pkg\_resources, распространяемый вместе с setuptools, предоставляет API для библиотек Python для доступа к их файлам ресурсов, а также для расширяемых приложений и платформ для автоматического обнаружения плагинов. Он также обеспечивает поддержку во время выполнения использования расширений C, находящихся внутри eggs-формата zip-файла, поддержку объединения пакетов, имеющих отдельно распространяемые модули или подпакеты, а также API для управления текущим «рабочим набором» активных пакетов Python.

{% hint style="danger" %}
Использование pkg\_resources устарело в пользу [importlib.resources](https://docs.python.org/3.11/library/importlib.resources.html#module-importlib.resources), [importlib.metadata](https://docs.python.org/3.11/library/importlib.metadata.html#module-importlib.metadata) и их бэкпортов ([importlib\_resources](https://pypi.org/project/importlib\_resources), [importlib\_metadata](https://pypi.org/project/importlib\_metadata)). Некоторые полезные API также предоставляются [packaging](https://pypi.org/project/packaging) (например, требования requirements и анализ версий). Пользователям следует воздерживаться от нового использования pkg\_resources и работать над портированием решений на основе importlib.
{% endhint %}

## Обзор

Модуль pkg\_resources предоставляет средства выполнения для поиска, анализа, активации и использования установленных дистрибутивов Python. Некоторые из более продвинутых функций (в частности, поддержка параллельной установки нескольких версий) основаны конкретно на формате "egg" (либо в виде zip-архива, либо в подкаталоге), в то время как другие (например, обнаружение плагинов) будут работать правильно, пока каталоги метаданных "egg-info" доступны для соответствующих дистрибутивов.

Eggs — это формат распространения модулей Python, по своей концепции схожий с "jars" Java или "gems" Ruby или форматом "wheel", определенным в PEP 427. Однако, в отличие от чистого формата распространения, eggs также можно устанавливать и добавлять напрямую в sys.path в качестве места импорта. При такой установке eggs доступны для обнаружения, а это означает, что они содержат метаданные, которые однозначно идентифицируют их содержимое и зависимости. Это означает, что установленное egg может быть автоматически найдено и добавлено в sys.path в ответ на простые запросы вида «принеси мне все, что мне нужно, чтобы использовать поддержку PDF в документах». Эта функция позволяет взаимно конфликтующим версиям дистрибутива сосуществовать в одной и той же установке Python, при этом отдельные приложения активируют нужную версию во время выполнения, манипулируя содержимым sys.path (это отличается от подхода к виртуальной среде, который предполагает создание изолированных сред для каждого приложения).

Для объяснения возможностей, предлагаемых этим модулем, необходимы следующие термины:

* project - Библиотека, платформа, скрипт, плагин, приложение или набор данных или других ресурсов или некоторая их комбинация. Предполагается, что проекты имеют «относительно уникальные» имена, например, имена, зарегистрированные с помощью PyPI.
* release - Снимок проекта в определенный момент времени, обозначаемый идентификатором версии.
* distribution - Файл или файлы, представляющие конкретный выпуск.
* importable distribution - Файл или каталог, который, если он помещен в sys.path, позволяет Python импортировать любые содержащиеся в нем модули.
* pluggable distribution - Импортируемый дистрибутив, имя файла которого однозначно идентифицирует его выпуск (т. е. проект и версию), а содержимое которого однозначно указывает, какие выпуски других проектов будут удовлетворять его требованиям времени выполнения.
* extra - это необязательная функция выпуска, которая может налагать дополнительные требования к времени выполнения. Например, если для поддержки PDF в docutils требуется наличие библиотеки поддержки PDF, docutils может определить поддержку PDF как дополнительную "extra" и перечислить, какие другие версии проекта должны быть доступны, чтобы ее обеспечить.
* environment - Коллекция дистрибутивов, потенциально доступных для импорта, но не обязательно активных. В среде может присутствовать более одного дистрибутива (т.е. версии выпуска) для данного проекта.
* working set - Коллекция дистрибутивов, фактически доступных для импорта, как в sys.path. В рабочем наборе может присутствовать не более одного дистрибутива (релизной версии) данного проекта, иначе возникнет неясность относительно того, что импортировать.
* eggs - это подключаемые дистрибутивы в одном из трех форматов, поддерживаемых в настоящее время pkg\_resources. Существуют built eggs, developmant eggs и eggs links. Built eggs — это каталоги или zip-файлы, имена которых заканчиваются на .egg и соответствуют соглашениям об именах eggs, и содержат подкаталог EGG-INFO (заархивированный или другой). Developmant eggs — это обычные каталоги кода Python с одним или несколькими подкаталогами ProjectName.egg-info. Формат developmant eggs также используется для предоставления версии дистрибутива по умолчанию, доступной программному обеспечению, которое не использует pkg\_resources для запроса определенных версий. Eggs links — это файлы \*.egg-link, которые содержат имя built или developmant egg для поддержки символических ссылок на платформах, которые не имеют собственных символических ссылок (или где поддержка символических ссылок ограничена).

Для получения дополнительной информации об этих терминах и концепциях см. также этот [архитектурный обзор](https://mail.python.org/pipermail/distutils-sig/2005-June/004652.html) pkg\_resources и Python Eggs в целом.

## Справочник по API

### Поддержка пакетов пространства имен

Пакет пространства имен — это пакет, который содержит только другие пакеты и модули и не имеет собственного содержимого. Такие пакеты можно разделить на несколько отдельно упакованных дистрибутивов. Обычно они используются для разделения больших пакетов, созданных одной организацией, например, в пакете пространства имен zope для пакетов Zope Corporation и в пакете пространства имен peak для Python Enterprise Application Kit.

Чтобы создать пакет пространства имен, вы указываете его в аргументе namespace\_packages функции setup() в файле setup.py вашего проекта. (Дополнительную информацию об этом см. в [документации по setuptools для пакетов пространства имен](rukovodstvo-polzovatelya-setuptools/obnaruzhenie-paketov-i-pakety-prostranstva-imen.md#poisk-paketov-prostranstva-imen)). Кроме того, необходимо добавить вызов declare\_namespace() в файл(ы) `__init__.py` пакета:

* declare\_namespace(name) - Объявляет, что имя пакета, разделенное точками, является «пакетом пространства имен», содержащиеся в нем пакеты и модули могут быть распределены по нескольким дистрибутивам. `__path__` именованного пакета будет расширен за счет включения соответствующего пакета во все дистрибутивы на sys.path, содержащие пакет с таким именем. (Точнее, если find\_module(name) импортера возвращает загрузчик, то он также будет искать содержимое пакета.) Всякий раз, когда вызывается метод active() дистрибутива, он проверяет наличие пакетов пространства имен и обновляет их содержимое `__path__` соответственно.

Приложениям, которые манипулируют пакетами пространства имен или напрямую изменяют sys.path во время выполнения, также может потребоваться использовать эту функцию API:

* fixup\_namespace\_packages(path\_item) - Объявляет, что path\_item — это новый элемент, добавленный в sys.path, который, возможно, потребуется использовать для обновления существующих пакетов пространства имен. Обычно это вызывается для вас, когда egg автоматически добавляется в sys.path, но если ваше приложение изменяет sys.path, чтобы включить местоположения, которые могут содержать части пакета пространства имен, вам нужно будет вызвать эту функцию, чтобы убедиться, что они добавлены. к существующим пакетам пространства имен.

Хотя по умолчанию pkg\_resources поддерживает только пакеты пространства имен для импортеров файловой системы и zip, вы можете расширить его поддержку для других «импортеров», совместимых с PEP 302, с помощью функции register\_namespace\_handler(). Подробности см. в разделе ниже «[Поддержка пользовательских импортеров](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#podderzhka-polzovatelskikh-importerov)».

### Объекты WorkingSet

Класс WorkingSet предоставляет доступ к коллекции «активных» дистрибутивов. В общем, существует только один значимый экземпляр рабочего набора: тот, который представляет дистрибутивы, которые в данный момент активны в sys.path. Этот глобальный экземпляр доступен под именем working\_set в модуле pkg\_resources. Однако специализированные инструменты могут захотеть манипулировать рабочими наборами, которые не соответствуют sys.path, и, следовательно, могут захотеть создать другие экземпляры WorkingSet.

Важно отметить, что глобальный объект working\_set инициализируется из sys.path при первом импорте pkg\_resources, но обновляется только в том случае, если вы выполняете все будущие манипуляции с sys.path через API pkg\_resources. Если вы вручную изменяете sys.path, вам необходимо вызвать соответствующие методы экземпляра working\_set, чтобы обеспечить его синхронизацию. К сожалению, Python не предоставляет никакого способа обнаружить произвольные изменения в объекте списка, таком как sys.path, поэтому pkg\_resources не может автоматически обновлять working\_set на основе изменений в sys.path.

* WorkingSet(entries=None) - Создает WorkingSet из итерации записей пути. Если entries не указаны, по умолчанию используется значение sys.path во время вызова конструктора. Обратите внимание, что обычно вы не создаете экземпляры WorkingSet самостоятельно, а вместо этого явно или неявно используете глобальный экземпляр working\_set. По большей части API pkg\_resources спроектирован так, что по умолчанию используется working\_set, так что вам не придется большую часть времени явно ссылаться на него.

Все дистрибутивы, доступные непосредственно в sys.path, будут активированы автоматически при импорте pkg\_resources. Такое поведение может вызвать конфликты версий для приложений, которым требуются версии этих дистрибутивов, отличные от версий по умолчанию. Чтобы справиться с этой ситуацией, pkg\_resources проверяет наличие атрибута `__requires__` в модуле `__main__` при инициализации рабочего набора по умолчанию и использует его, чтобы убедиться, что активирована подходящая версия каждого затронутого дистрибутива. Например:

```python
 # Должен быть установлен перед импортом pkg_resources
__requires__ = ["CherryPy < 3"]
import pkg_resources
```

#### Базовые методы WorkingSet

Следующие методы объектов WorkingSet также доступны как функции уровня модуля в pkg\_resources, которые применяются к экземпляру working\_set по умолчанию. Таким образом, вы можете использовать, например, pkg\_resources.require() как сокращение от pkg\_resources.working\_set.require():

* require(\*requirements) - Убедитесь, что дистрибутивы, соответствующие требованиям requirements, активированы. Требования requirements должны быть строкой или (возможно, вложенной) последовательностью, определяющей требуемые дистрибутивы и версии. Возвращаемое значение — это последовательность дистрибутивов, которые необходимо активировать для выполнения требований; включены все соответствующие дистрибутивы, даже если они уже были активированы в этом рабочем наборе. Синтаксис спецификаторов требований см. в разделе «[Парсинг требований](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#parsing-requirements)» ниже. В общем, вам не обязательно вызывать этот метод напрямую. Он предназначен больше для быстрого написания сценариев и взлома интерактивных интерпретаторов, чем для промышленного использования. Если вы создаете реальную библиотеку или приложение, настоятельно рекомендуется создать сценарий «setup.py» с помощью setuptools и объявить там все свои требования. Таким образом, такие инструменты, как pip, могут автоматически определять требования вашего пакета и соответствующим образом обрабатывать их. Обратите внимание, что вызов `require('SomePackage')` не установит SomePackage, если он еще не установлен. Если вам нужно это сделать, вместо этого вам следует использовать метод resolve(), который позволяет вам передать обратный вызов установщика, который будет вызываться, когда необходимый дистрибутив не может быть найден на локальном компьютере. Затем вы можете заставить этот обратный вызов отображать диалоговое окно, автоматически загружать необходимый дистрибутив или что-то еще, подходящее для вашего приложения. Дополнительную информацию см. в документации ниже по методу resolve(), а также по методу obtain() объектов Environment.
* run\_script(requires, script\_name) - Находит дистрибутив, указанный в списке requires, и запускает его сценарий script\_name. Параметр requires должен быть строкой, содержащей спецификатор требования. (Синтаксис см. ниже в разделе «[Парсинг требований](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#parsing-requirements)».) Скрипт, если он найден, будет выполнен в _глобальных переменных вызывающего объекта_. Это связано с тем, что этот метод предназначен для вызова из сценариев-оболочек, которые действуют как прокси для «настоящих» сценариев в дистрибутиве. Скрипту-оболочке обычно не нужно ничего делать, кроме вызова этой функции с правильными аргументами. Если вам нужен больший контроль над средой выполнения скрипта, вы, вероятно, захотите вместо этого использовать метод run\_script() [API метаданных](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#metadata-api) объекта Distribution.
* iter\_entry\_points(group, name=None) - Получение объектов точки входа из группы group, совпадающей с name. Если name равно None, выдаются все точки входа в group из всех дистрибутивов в рабочем наборе, в противном случае выдаются только те точки входа, которые соответствуют как group, так и name. Точки входа получаются из активных распределений в том порядке, в котором распределения появляются в рабочем наборе. (Для глобального working\_set это должен быть тот же порядок, в котором они перечислены в sys.path.) Обратите внимание, что внутри точек входа, объявленных отдельным дистрибутивом, не существует определенного порядка. Дополнительную информацию см. в разделе «[Точки входа](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#tochki-vkhoda-entry-points)» ниже.

#### Методы и атрибуты WorkingSet

Эти методы используются для запроса или управления содержимым определенного рабочего набора, поэтому их необходимо явно вызывать для конкретного экземпляра WorkingSet:

* add\_entry(entry) - Добавляет в записи entries элемент пути, найдя по нему любые дистрибутивы. Вам следует использовать это, когда вы добавляете дополнительные элементы в sys.path и хотите, чтобы глобальный working\_set отражал эти изменения. Этот метод также вызывается конструктором WorkingSet() во время инициализации. Этот метод использует `find_distributions(entry, True)` для поиска дистрибутивов, соответствующих записи пути, а затем добавляет их add(). Однако entry всегда добавляется к атрибуту entries, даже если она уже присутствует. (Это связано с тем, что sys.path может содержать одно и то же значение более одного раза, и атрибут entries должен отражать это.)
* `__contains__(dist)` - True, если в этом рабочем наборе WorkingSet активно dist. Обратите внимание, что в данном WorjingSet может быть активен только один дистрибутив для данного проекта.
* `__iter__()` - Получение дистрибутивов для недублирующихся проектов в рабочем наборе. Порядок получения дистрибутивов — это порядок, в котором записи путей элементов были добавлены в рабочий набор.
* find(req) - Ищет запрос, соответствующий req (экземпляр Requirement). Если для запрошенного проекта существует активный дистрибутив, он возвращается, если он соответствует требованию к версии, указанному в req. Но если для проекта существует активный дистрибутив, который не соответствует требованию, возникает VersionConflict. Если для запрошенного проекта нет активного распространения, возвращается значение None.
* resolve(requirements, env=None, installer=None) - Список всех дистрибутивов, необходимых для (рекурсивного) удовлетворения требований requirements. Требования requirements должны представлять собой последовательность объектов Requirement. env, если он указан, должен быть экземпляром Environment. Если он не указан, среда создается из entries рабочего набора. Установщик installer, если он есть, будет вызываться при каждом требованию, которое не может быть выполнено уже установленным дистрибутивом; он должен вернуть Distribution или None. (Для получения дополнительной информации об аргументе installer см. метод obtain() [объектов среды](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#obekty-environment) ниже.)
* add(dist, entry=None) - Добавляет dist в рабочий набор, связанный с записью entry. Если entry не указана, по умолчанию используется dist.location. При выходе из этой процедуры entry добавляется в конец рабочего набора entries (если она еще не присутствовала). dist добавляется в рабочий набор только в том случае, если он предназначен для проекта, в наборе которого еще нет активного дистрибутива. Если он успешно добавлен, будут вызваны любые обратные вызовы, зарегистрированные с помощью метода subscribe(). (См. «[Получение уведомлений об изменениях](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#poluchenie-uvedomlenii-ob-izmeneniyakh)» ниже.) Примечание: add() автоматически вызывается методом require(), поэтому обычно вам не нужно использовать этот метод напрямую.
* entries - Этот атрибут представляет собой «теневой» путь sys.path, который в первую очередь полезен для отладки. Если у вас возникли проблемы с импортом, вам следует проверить записи entries глобального объекта working\_set по sys.path, чтобы убедиться, что они совпадают. Если это не так, то какая-то часть вашей программы манипулирует sys.path без соответствующего обновления working\_set. ВАЖНОЕ ПРИМЕЧАНИЕ: не манипулируйте этим атрибутом напрямую! Установка его равным sys.path не решит вашу проблему, точно так же, как наложение черной ленты на индикатор «предупреждения двигателя» не исправит вашу машину! Если этот атрибут не синхронизирован с sys.path, это просто индикатор проблемы, а не ее причина.

#### Получение уведомлений об изменениях

Расширяемым приложениям и платформам может потребоваться получение уведомления, когда в рабочий набор добавляется новый дистрибутив (например, подключаемый модуль). Для этого предназначены метод subscribe() и функция add\_activation\_listener().

* subscribe(callback) - Вызывает callback(distribution) один раз для каждого активного распределения, которое находится в наборе сейчас или будет добавлено позже. Поскольку обратный вызов вызывается для уже активных дистрибутивов, вам не нужно самостоятельно перебирать рабочий набор для работы с существующими элементами; просто пропишите callback и будьте готовы к тому, что он будет вызван сразу этим методом. Обратите внимание, что обратные вызовы _**не должны**_ допускать распространения исключений, иначе они будут мешать работе других обратных вызовов и, возможно, приведут к несогласованному состоянию рабочего набора. Обратные вызовы должны использовать блок try/except для игнорирования, регистрации или иной обработки любых ошибок, особенно потому, что код, вызвавший вызов обратного вызова, вряд ли сможет обрабатывать ошибки лучше, чем сам обратный вызов.
* `pkg_resources.add_activation_listener()` - это альтернативное написание  `pkg_resources.working_set.subscribe()`

#### Поиск плагинов

Расширяемые приложения иногда имеют «каталог плагинов» или набор каталогов плагинов, из которых они хотят загружать точки входа или другие метаданные. Метод find\_plugins() позволяет вам сделать это, сканируя среду на предмет новейшей версии каждого проекта, которую можно безопасно загрузить без конфликтов или отсутствия требований.

* `find_plugins(plugin_env, full_env=None, fallback=True)` - Сканирует plugin\_env и определяет, какие дистрибутивы можно добавить в этот рабочий набор без конфликтов версий или отсутствия требований. Пример использования:

```python
distributions, errors = working_set.find_plugins(
    Environment(plugin_dirlist)
)
map(working_set.add, distributions)  # добавление plugins+libs в sys.path
print "Couldn't load", errors        # отображение ошибок
```

plugin\_env должен быть экземпляром среды Environment, который содержит только те дистрибутивы, которые находятся в «каталоге плагинов» или каталогах проекта. full\_env, если он указан, должен быть экземпляром Environment, содержащим все доступные на данный момент дистрибутивы.

Если full\_env не указан, он создается автоматически из рабочего набора, из которого вызывается этот метод, что обычно означает, что каждый каталог в sys.path будет сканироваться на наличие дистрибутивов.

Этот метод возвращает кортеж из двух элементов: (distributions, error\_info), где distributions — это список дистрибутивов, найденных в plugin\_env, которые можно было загрузить, а также любые другие дистрибутивы, необходимые для разрешения их зависимостей. error\_info — это словарь, сопоставляющий дистрибутивы выгружаемых плагинов с экземпляром исключения, описывающим произошедшую ошибку. Обычно это экземпляр DistributionNotFound или VersionConflict.

Большинство приложений будут использовать этот метод в основном для главного экземпляра working\_set в pkg\_resources, а затем немедленно добавлять возвращаемые дистрибутивы в рабочий набор, чтобы они были доступны в sys.path. Это позволит найти любые точки входа и активировать любое другое отслеживание метаданных и перехваты.

Алгоритм разрешения, используемый find\_plugins(), следующий. Сначала сортируются имена проектов дистрибутивов, присутствующих в plugin\_env. Затем eggs каждого проекта проверяются в порядке убывания версий (т. е. сначала самая новая версия).

Предпринимается попытка разрешить зависимости каждого eggs. Если попытка успешна, egg и его зависимости добавляются в выходной список и во временную копию рабочего набора. Процесс разрешения продолжается со следующим именем проекта, и более старые eggs для этого проекта не рассматриваются.

Однако если попытка разрешения не удалась, ошибка добавляется в словарь ошибок. Если флаг возврата имеет значение true, пробуется следующая более старая версия плагина, пока не будет найдена рабочая версия. Если false, процесс разрешения продолжается со следующим именем проекта плагина.

Некоторые приложения могут иметь более строгие требования к резервному использованию, чем другие. Например, приложение, имеющее схему базы данных или постоянные объекты, может не иметь возможности безопасно понизить версию пакета. Другие могут захотеть убедиться, что новая конфигурация плагина либо на 100% хороша, либо вернуться к заведомо исправной конфигурации. (То есть они могут захотеть вернуться к известной конфигурации, если возвращаемое значение error\_info не пусто.)

Обратите внимание, что этот алгоритм отдает приоритет удовлетворению зависимостей имен проектов в алфавитном порядке в случае конфликтов версий. Если двум проектам с именами «AaronsPlugin» и «ZekesPlugin» нужны разные версии «TomsLibrary», то «AaronsPlugin» выиграет, а «ZekesPlugin» будет отключен из-за конфликта версий.

### Объекты Environment

Среда "environment" — это набор объектов Distribution, обычно тех, которые присутствуют и потенциально могут быть импортированы на текущей платформе. Объекты Environment используются pkg\_resources для индексации доступных дистрибутивов во время разрешения зависимостей.

* `Environment(search_path=None, platform=get_supported_platform(), python=PY_MAJOR)` - Создает снапшот среды, просканировав search\_path на наличие дистрибутивов, совместимых с платформой и Python. search\_path должен представлять собой последовательность строк, например, которая может использоваться в sys.path. Если search\_path не указан, используется sys.path. platform — необязательная строка, определяющая имя платформы, с которой должны быть совместимы дистрибутивы для конкретной платформы. Если не указано, по умолчанию используется текущая платформа. python — необязательная строка, указывающая желаемую версию Python (например, "2.4"); по умолчанию используется текущая версия. Вы можете явно установить для platform (и/или Python) значение None, если хотите включить все дистрибутивы, а не только те, которые совместимы с работающей платформой или версией Python. Обратите внимание, что search\_path немедленно сканируется на наличие дистрибутивов, и результирующая Environment представляет собой снимок найденных дистрибутивов. Он не обновляется автоматически, если состояние системы изменяется, например, по причине установки или удаления дистрибутивов.
* `__getitem__(project_name)` - Возвращает список дистрибутивов для данного имени проекта, упорядоченный от самой новой к самой старой версии. (И приоритет формата от самого высокого до самого низкого для дистрибутивов, содержащих одну и ту же версию проекта.) Если для проекта нет дистрибутивов, возвращается пустой список.
* `__iter__()` - Получение уникальных имен проектов дистрибутивов в этой среде. Полученные имена всегда пишутся строчными буквами.
* `add(dist)` - Добавляет dist в среду, если он соответствует платформе и версии Python, указанным во время создания, и только если дистрибутив еще не был добавлен. (т.е. добавление одного и того же дистрибутива более одного раза недопустимо.)
* `remove(dist)` - Удаляет dist из среды.
* `can_add(dist)` - Приемлемо ли добавление dist для этой среды? Если оно несовместимо со значениями платформы и версии Python, указанными при создании среды, возвращается ложное значение.
* `__add__(dist_or_env)` (`+` operator) - Добавляет дистрибутив или среду в экземпляр Environment, возвращая _**новый**_ объект среды, содержащий все дистрибутивы, ранее содержащиеся в обоих. Новая среда будет иметь platform и python со значением None, что означает, что она не будет отклонять добавление в нее каких-либо дистрибутивов; он просто примет все, что будет добавлено. Если вы хотите, чтобы добавленные элементы фильтровались по платформе и версии Python или вы хотите добавить их в _**один и тот же**_ экземпляр среды, вместо этого следует использовать добавление на месте (`+=`).
* `__iadd__(dist_or_env)` (`+=` operator) - Добавляет дистрибутив или среду в экземпляр Environment на месте, обновив существующий экземпляр и вернув его. Атрибуты фильтра platform и python вступают в силу, поэтому дистрибутивы в исходном коде, у которых нет подходящей строки платформы или версии Python, игнорируются.
* `best_match(req, working_set, installer=None)` - Ищет наиболее подходящий req для дистрибутива, который можно использовать на working\_set. При этом вызывается метод find(req) working\_set, чтобы проверить, активен ли уже подходящий дистрибутив. (Это может вызвать конфликт версий VersionConflict, если неподходящая версия проекта уже активна в указанном working\_set.) Если подходящий дистрибутив не активен, этот метод возвращает новейший дистрибутив в среде, соответствующий Requirement в req. Если подходящий дистрибутив не найден и предоставлен установщик, то будет возвращен результат вызова метода obtain(req, installer) среды.
* `obtain(requirement, installer=None)` - Получает дистрибутив, соответствующий требованиям (например, через загрузку). В базовом классе Environment эта процедура просто возвращает installer(requirement), если только installer не имеет значения None, и в этом случае вместо него возвращается None. Этот метод представляет собой хук, который позволяет подклассам попробовать другие способы получения дистрибутива, прежде чем вернуться к аргументу установщика.
* `scan(search_path=None)` - Сканирует search\_path на наличие дистрибутивов, которые можно использовать на платформе platform. Все найденные дистрибутивы добавляются в среду. search\_path должен представлять собой последовательность строк, например, которая может использоваться в sys.path. Если он не указан, используется sys.path. Добавляются только дистрибутивы, соответствующие версии платформы/Python, определенной при инициализации. Этот метод представляет собой сокращенный вариант использования функции find\_distributions() для поиска распределений каждого элемента в search\_path, а затем вызова add() для добавления каждого из них в среду.

### Объекты Requirement

Объекты Requirement выражают, какие версии проекта подходят для той или иной цели. Эти объекты (или их строковая форма) используются различными API-интерфейсами pkg\_resources для поиска дистрибутивов, необходимых сценарию или дистрибутиву.

#### Парсинг requirements

* `parse_requirements(s)` - Возвращает объекты Requirement для строки или итерации строк. Каждое требование должно начинаться с новой строки. Синтаксис см. ниже.
* `Requirement.parse(s)` - Создает объект Requirement из строки или итерации строк. Ошибка ValueError возникает, если строка или строки не содержат допустимого спецификатора требования или содержат более одного спецификатора. (Чтобы проанализировать несколько спецификаторов из строки или итерации строк, используйте вместо этого parse\_requirements().) Синтаксис спецификатора требования полностью определен в PEP 508. Некоторые примеры допустимых спецификаторов требований:

```python
FooProject >= 1.2
Fizzy [foo, bar]
PickyThing>1.6,<=1.9,!=1.8.6
SomethingWhoseVersionIDontCareAbout
SomethingWithMarker[foo]>1.0;python_version<"2.7"
```

Имя проекта — единственная обязательная часть строки требования, и если это единственное, что указано, требование будет принимать любую версию этого проекта.

"extras" в требовании используются для запроса дополнительных функций проекта, для работы которых могут потребоваться дополнительные дистрибутивы проекта. Например, если бы гипотетический проект «Report-O-Rama» предлагал дополнительную поддержку PDF, для обеспечения такой поддержки могла бы потребоваться дополнительная библиотека. Таким образом, проект, которому необходимы функции PDF Report-O-Rama, может использовать требование `Report-O-Rama[PDF]` для запроса установки или активации как Report-O-Rama, так и любых библиотек, которые ему необходимы для обеспечения поддержки PDF. Например, вы можете использовать:

```bash
pip install Report-O-Rama[PDF]
```

Чтобы установить необходимые пакеты, используйте pip или вызовите pkg\_resources.require('Report-O-Rama\[PDF]'), чтобы добавить необходимые дистрибутивы в sys.path во время выполнения.

«Маркеры» в требовании используются для указания того, когда требование должно быть установлено — требование будет установлено, если маркер оценивается как истинный в текущей среде. Например, указание `argparse;python_version<"3.0"` не будет установлено в среде Python 3, но будет установлено в среде Python 2.

#### Методы и атрибуты Requirment

* `__contains__(dist_or_version)` - Возвращает true, если dist\_or\_version соответствует критериям этого требования. Если dist\_or\_version является объектом Distribution, имя его проекта должно совпадать с именем проекта требования, а его версия должна соответствовать критериям версии требования. Если dist\_or\_version представляет собой строку, она анализируется с помощью служебной функции parse\_version(). В противном случае предполагается, что это уже проанализированная версия. Спецификаторы версий объекта Requirement (.specs) внутренне сортируются по возрастанию версий и используются для определения допустимых диапазонов версий. Соседние избыточные условия эффективно объединяются (например, `">1, >2"` дает те же результаты, что и `">2"`, а `"<2,<3"` дает те же результаты, что и `"<2"`). Версии `"!="` исключаются из диапазонов, в которые они попадают. Версия, проверяемая на приемлемость, затем проверяется на членство в результирующих диапазонах.
* `__eq__(other_requirement)` - Требование сравнивается с другим требованием, если они имеют одинаковые имена проектов, спецификаторы версий и "extras" без учета регистра. (Порядок, в котором указаны дополнительные элементы и спецификаторы версий, также игнорируется.) Равные требования также имеют равные хэши, поэтому требования можно использовать в наборах или в качестве ключей словаря.
* `__str__()` - Строковая форма Requirement — это строка, которая при передаче в Requirement.parse() вернет равный объект Requirement.
* `project_name` - Название необходимого проекта
* `key` - Версия project\_name, написанная только строчными буквами, полезная для сравнения или индексирования.
* `extras` - Кортеж имен "extras", которые требует это требование. (Они будут написаны строчными буквами и нормализованы с помощью служебной функции синтаксического анализа `safe_extra()`, поэтому они могут не в точности соответствовать дополнительным параметрам, с которыми было создано требование.)
* `specs` - Список кортежей `(op,version)`, отсортированных в порядке возрастания проанализированной версии. **op** в каждом кортеже — это оператор сравнения, представленный в виде строки. **version** — это (неанализируемый) номер версии.
* `marker` - Экземпляр `package.markers.Marker`, который позволяет оценивать текущую среду. Может быть None, если маркер не указан.
* `url` - Местоположение для загрузки требования, если оно указано.

### Точки входа (Entry Points)

Точки входа — это простой способ «рекламировать» объекты Python (такие как функции или классы) для использования другими дистрибутивами. Расширяемые приложения и платформы могут искать точки входа с определенным именем или группой либо из определенного дистрибутива, либо из всех активных дистрибутивов по sys.path, а затем проверять или загружать объявленные объекты по своему желанию.

Точки входа принадлежат "groups", имена которых разделены точками, аналогично имени пакета или модуля Python. Например, пакет setuptools использует точку входа с именем `distutils.commands` для поиска команд, определенных расширениями distutils. **setuptools** рассматривает имена точек входа, определенные в этой группе, как допустимые команды для сценария установки.

Аналогичным образом другие пакеты могут определять свои собственные группы точек входа, либо используя динамические имена внутри группы (например, `distutils.commands`), либо, возможно, используя предопределенные имена внутри группы. Например, платформа ведения блога, предлагающая различные перехватчики до или после публикации, может определить группу точек входа и искать точки входа с именами `"pre_process"` и `"post_process"` внутри этой группы.

Чтобы объявить точку входа, проекту необходимо использовать setuptools и предоставить аргумент entry\_points функции `setup()` в своем скрипте установки, чтобы точки входа были включены в метаданные дистрибутива. Более подробную информацию см. в разделе «[Поведение рекламы](rukovodstvo-polzovatelya-setuptools/tochki-vkhoda-entry-poynts.md#reklamnoe-povedenie)».

Каждый дистрибутив проекта может рекламировать не более одной точки входа с заданным именем в одной группе точек входа. Например, расширение distutils может объявлять две разные точки входа `distutils.commands`, если они имеют разные имена. Однако нет ничего, что мешает _**разным**_ проектам рекламировать одноимённые точки входа в одной группе. В некоторых случаях это желательно, поскольку приложение или платформа, использующая точки входа, может вызывать их как перехватчики или каким-либо другим образом комбинировать их. Приложение или платформа должны решить, что делать, если несколько дистрибутивов объявляют точку входа; некоторые возможности включают использование обеих точек входа, отображение сообщения об ошибке, использование первой точки, найденной в порядке sys.path, и т. д.

#### Удобный API

В следующих функциях аргумент dist может быть экземпляром Distribution, экземпляром Requirement или строкой, определяющей требование (т.е. имя проекта, версию и т. д.). Если аргументом является строка или требование, указанный дистрибутив находится (и добавляется в sys.path, если он еще не существует). Если соответствующий дистрибутив недоступен, возникнет ошибка.

Аргумент группы group должен представлять собой строку, содержащую точечный идентификатор, идентифицирующий группу точек входа. Если вы определяете группу точек входа, вам следует включить некоторую часть имени вашего пакета в имя группы, чтобы избежать конфликта с группами точек входа других пакетов.

* `load_entry_point(dist, group, name)` - Загружает именованную точку входа из указанного дистрибутива или вызывает ImportError.
* `get_entry_info(dist, group, name)` - Возвращает объект EntryPoint для данной группы group и имени name из указанного дистрибутива. Возвращает None, если распределение dist не объявило соответствующую точку входа.
* `get_entry_map(dist, group=None)` - Возвращает карту точек входа дистрибутива для группы group или полную карту входа для дистрибутива. Эта функция всегда возвращает словарь, даже если дистрибутив не объявляет никаких точек входа. Если указана группа, словарь сопоставляет имена точек входа соответствующему объекту EntryPoint. Если группа group имеет значение None, словарь сопоставляет имена групп словарям, которые затем сопоставляют имена точек входа с соответствующим экземпляром EntryPoint в этой группе.
* `iter_entry_points(group, name=None)` - Выдает объекты точки входа из группы group, совпадающей с именем name. Если name равно None, выдаются все точки входа в группе из всех дистрибутивов в рабочем наборе по sys.path, в противном случае выдаются только те точки входа, которые соответствуют как группе group, так и имени name. Точки входа получаются из активных раздач в том порядке, в котором они появляются в sys.path. (Однако внутри точек входа для конкретного дистрибутива нет определенного порядка.) (Этот API на самом деле является методом глобального объекта working\_set; дополнительную информацию см. в разделе «[Основные методы WorkingSet](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#bazovye-metody-workingset)» выше.)

#### Создание и синтаксический анализ

### Metadata API

### Поддержка пользовательских импортеров
