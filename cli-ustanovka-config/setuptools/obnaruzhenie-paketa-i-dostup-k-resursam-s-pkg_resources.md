# Обнаружение пакета и доступ к ресурсам с pkg\_resources

Модуль pkg\_resources, распространяемый вместе с setuptools, предоставляет API для библиотек Python для доступа к их файлам ресурсов, а также для расширяемых приложений и платформ для автоматического обнаружения плагинов. Он также обеспечивает поддержку во время выполнения использования расширений C, находящихся внутри eggs-формата zip-файла, поддержку объединения пакетов, имеющих отдельно распространяемые модули или подпакеты, а также API для управления текущим «рабочим набором» активных пакетов Python.

{% hint style="danger" %}
Использование pkg\_resources устарело в пользу [importlib.resources](https://docs.python.org/3.11/library/importlib.resources.html#module-importlib.resources), [importlib.metadata](https://docs.python.org/3.11/library/importlib.metadata.html#module-importlib.metadata) и их бэкпортов ([importlib\_resources](https://pypi.org/project/importlib\_resources), [importlib\_metadata](https://pypi.org/project/importlib\_metadata)). Некоторые полезные API также предоставляются [packaging](https://pypi.org/project/packaging) (например, требования requirements и анализ версий). Пользователям следует воздерживаться от нового использования pkg\_resources и работать над портированием решений на основе importlib.
{% endhint %}

## Обзор

Модуль pkg\_resources предоставляет средства выполнения для поиска, анализа, активации и использования установленных дистрибутивов Python. Некоторые из более продвинутых функций (в частности, поддержка параллельной установки нескольких версий) основаны конкретно на формате "egg" (либо в виде zip-архива, либо в подкаталоге), в то время как другие (например, обнаружение плагинов) будут работать правильно, пока каталоги метаданных "egg-info" доступны для соответствующих дистрибутивов.

Eggs — это формат распространения модулей Python, по своей концепции схожий с "jars" Java или "gems" Ruby или форматом "wheel", определенным в PEP 427. Однако, в отличие от чистого формата распространения, eggs также можно устанавливать и добавлять напрямую в sys.path в качестве места импорта. При такой установке eggs доступны для обнаружения, а это означает, что они содержат метаданные, которые однозначно идентифицируют их содержимое и зависимости. Это означает, что установленное egg может быть автоматически найдено и добавлено в sys.path в ответ на простые запросы вида «принеси мне все, что мне нужно, чтобы использовать поддержку PDF в документах». Эта функция позволяет взаимно конфликтующим версиям дистрибутива сосуществовать в одной и той же установке Python, при этом отдельные приложения активируют нужную версию во время выполнения, манипулируя содержимым sys.path (это отличается от подхода к виртуальной среде, который предполагает создание изолированных сред для каждого приложения).

Для объяснения возможностей, предлагаемых этим модулем, необходимы следующие термины:

* project - Библиотека, платформа, скрипт, плагин, приложение или набор данных или других ресурсов или некоторая их комбинация. Предполагается, что проекты имеют «относительно уникальные» имена, например, имена, зарегистрированные с помощью PyPI.
* release - Снимок проекта в определенный момент времени, обозначаемый идентификатором версии.
* distribution - Файл или файлы, представляющие конкретный выпуск.
* importable distribution - Файл или каталог, который, если он помещен в sys.path, позволяет Python импортировать любые содержащиеся в нем модули.
* pluggable distribution - Импортируемый дистрибутив, имя файла которого однозначно идентифицирует его выпуск (т. е. проект и версию), а содержимое которого однозначно указывает, какие выпуски других проектов будут удовлетворять его требованиям времени выполнения.
* extra - это необязательная функция выпуска, которая может налагать дополнительные требования к времени выполнения. Например, если для поддержки PDF в docutils требуется наличие библиотеки поддержки PDF, docutils может определить поддержку PDF как дополнительную "extra" и перечислить, какие другие версии проекта должны быть доступны, чтобы ее обеспечить.
* environment - Коллекция дистрибутивов, потенциально доступных для импорта, но не обязательно активных. В среде может присутствовать более одного дистрибутива (т.е. версии выпуска) для данного проекта.
* working set - Коллекция дистрибутивов, фактически доступных для импорта, как в sys.path. В рабочем наборе может присутствовать не более одного дистрибутива (релизной версии) данного проекта, иначе возникнет неясность относительно того, что импортировать.
* eggs - это подключаемые дистрибутивы в одном из трех форматов, поддерживаемых в настоящее время pkg\_resources. Существуют built eggs, developmant eggs и eggs links. Built eggs — это каталоги или zip-файлы, имена которых заканчиваются на .egg и соответствуют соглашениям об именах eggs, и содержат подкаталог EGG-INFO (заархивированный или другой). Developmant eggs — это обычные каталоги кода Python с одним или несколькими подкаталогами ProjectName.egg-info. Формат developmant eggs также используется для предоставления версии дистрибутива по умолчанию, доступной программному обеспечению, которое не использует pkg\_resources для запроса определенных версий. Eggs links — это файлы \*.egg-link, которые содержат имя built или developmant egg для поддержки символических ссылок на платформах, которые не имеют собственных символических ссылок (или где поддержка символических ссылок ограничена).

Для получения дополнительной информации об этих терминах и концепциях см. также этот [архитектурный обзор](https://mail.python.org/pipermail/distutils-sig/2005-June/004652.html) pkg\_resources и Python Eggs в целом.

## Справочник по API

### Поддержка пакетов пространства имен

Пакет пространства имен — это пакет, который содержит только другие пакеты и модули и не имеет собственного содержимого. Такие пакеты можно разделить на несколько отдельно упакованных дистрибутивов. Обычно они используются для разделения больших пакетов, созданных одной организацией, например, в пакете пространства имен zope для пакетов Zope Corporation и в пакете пространства имен peak для Python Enterprise Application Kit.

Чтобы создать пакет пространства имен, вы указываете его в аргументе namespace\_packages функции setup() в файле setup.py вашего проекта. (Дополнительную информацию об этом см. в [документации по setuptools для пакетов пространства имен](rukovodstvo-polzovatelya-setuptools/obnaruzhenie-paketov-i-pakety-prostranstva-imen.md#poisk-paketov-prostranstva-imen)). Кроме того, необходимо добавить вызов declare\_namespace() в файл(ы) `__init__.py` пакета:

* declare\_namespace(name) - Объявляет, что имя пакета, разделенное точками, является «пакетом пространства имен», содержащиеся в нем пакеты и модули могут быть распределены по нескольким дистрибутивам. `__path__` именованного пакета будет расширен за счет включения соответствующего пакета во все дистрибутивы на sys.path, содержащие пакет с таким именем. (Точнее, если find\_module(name) импортера возвращает загрузчик, то он также будет искать содержимое пакета.) Всякий раз, когда вызывается метод active() дистрибутива, он проверяет наличие пакетов пространства имен и обновляет их содержимое `__path__` соответственно.

Приложениям, которые манипулируют пакетами пространства имен или напрямую изменяют sys.path во время выполнения, также может потребоваться использовать эту функцию API:

* fixup\_namespace\_packages(path\_item) - Объявляет, что path\_item — это новый элемент, добавленный в sys.path, который, возможно, потребуется использовать для обновления существующих пакетов пространства имен. Обычно это вызывается для вас, когда egg автоматически добавляется в sys.path, но если ваше приложение изменяет sys.path, чтобы включить местоположения, которые могут содержать части пакета пространства имен, вам нужно будет вызвать эту функцию, чтобы убедиться, что они добавлены. к существующим пакетам пространства имен.

Хотя по умолчанию pkg\_resources поддерживает только пакеты пространства имен для импортеров файловой системы и zip, вы можете расширить его поддержку для других «импортеров», совместимых с PEP 302, с помощью функции register\_namespace\_handler(). Подробности см. в разделе ниже «[Поддержка пользовательских импортеров](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#podderzhka-polzovatelskikh-importerov)».

### Объекты WorkingSet

Класс WorkingSet предоставляет доступ к коллекции «активных» дистрибутивов. В общем, существует только один значимый экземпляр рабочего набора: тот, который представляет дистрибутивы, которые в данный момент активны в sys.path. Этот глобальный экземпляр доступен под именем working\_set в модуле pkg\_resources. Однако специализированные инструменты могут захотеть манипулировать рабочими наборами, которые не соответствуют sys.path, и, следовательно, могут захотеть создать другие экземпляры WorkingSet.

Важно отметить, что глобальный объект working\_set инициализируется из sys.path при первом импорте pkg\_resources, но обновляется только в том случае, если вы выполняете все будущие манипуляции с sys.path через API pkg\_resources. Если вы вручную изменяете sys.path, вам необходимо вызвать соответствующие методы экземпляра working\_set, чтобы обеспечить его синхронизацию. К сожалению, Python не предоставляет никакого способа обнаружить произвольные изменения в объекте списка, таком как sys.path, поэтому pkg\_resources не может автоматически обновлять working\_set на основе изменений в sys.path.

* WorkingSet(entries=None) - Создает WorkingSet из итерации записей пути. Если entries не указаны, по умолчанию используется значение sys.path во время вызова конструктора. Обратите внимание, что обычно вы не создаете экземпляры WorkingSet самостоятельно, а вместо этого явно или неявно используете глобальный экземпляр working\_set. По большей части API pkg\_resources спроектирован так, что по умолчанию используется working\_set, так что вам не придется большую часть времени явно ссылаться на него.

Все дистрибутивы, доступные непосредственно в sys.path, будут активированы автоматически при импорте pkg\_resources. Такое поведение может вызвать конфликты версий для приложений, которым требуются версии этих дистрибутивов, отличные от версий по умолчанию. Чтобы справиться с этой ситуацией, pkg\_resources проверяет наличие атрибута `__requires__` в модуле `__main__` при инициализации рабочего набора по умолчанию и использует его, чтобы убедиться, что активирована подходящая версия каждого затронутого дистрибутива. Например:

```python
 # Должен быть установлен перед импортом pkg_resources
__requires__ = ["CherryPy < 3"]
import pkg_resources
```

#### Базовые методы WorkingSet

Следующие методы объектов WorkingSet также доступны как функции уровня модуля в pkg\_resources, которые применяются к экземпляру working\_set по умолчанию. Таким образом, вы можете использовать, например, pkg\_resources.require() как сокращение от pkg\_resources.working\_set.require():

* require(\*requirements) - Убедитесь, что дистрибутивы, соответствующие требованиям requirements, активированы. Требования requirements должны быть строкой или (возможно, вложенной) последовательностью, определяющей требуемые дистрибутивы и версии. Возвращаемое значение — это последовательность дистрибутивов, которые необходимо активировать для выполнения требований; включены все соответствующие дистрибутивы, даже если они уже были активированы в этом рабочем наборе. Синтаксис спецификаторов требований см. в разделе «[Парсинг требований](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#parsing-requirements)» ниже. В общем, вам не обязательно вызывать этот метод напрямую. Он предназначен больше для быстрого написания сценариев и взлома интерактивных интерпретаторов, чем для промышленного использования. Если вы создаете реальную библиотеку или приложение, настоятельно рекомендуется создать сценарий «setup.py» с помощью setuptools и объявить там все свои требования. Таким образом, такие инструменты, как pip, могут автоматически определять требования вашего пакета и соответствующим образом обрабатывать их. Обратите внимание, что вызов `require('SomePackage')` не установит SomePackage, если он еще не установлен. Если вам нужно это сделать, вместо этого вам следует использовать метод resolve(), который позволяет вам передать обратный вызов установщика, который будет вызываться, когда необходимый дистрибутив не может быть найден на локальном компьютере. Затем вы можете заставить этот обратный вызов отображать диалоговое окно, автоматически загружать необходимый дистрибутив или что-то еще, подходящее для вашего приложения. Дополнительную информацию см. в документации ниже по методу resolve(), а также по методу obtain() объектов Environment.
* run\_script(requires, script\_name) - Находит дистрибутив, указанный в списке requires, и запускает его сценарий script\_name. Параметр requires должен быть строкой, содержащей спецификатор требования. (Синтаксис см. ниже в разделе «[Парсинг требований](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#parsing-requirements)».) Скрипт, если он найден, будет выполнен в _глобальных переменных вызывающего объекта_. Это связано с тем, что этот метод предназначен для вызова из сценариев-оболочек, которые действуют как прокси для «настоящих» сценариев в дистрибутиве. Скрипту-оболочке обычно не нужно ничего делать, кроме вызова этой функции с правильными аргументами. Если вам нужен больший контроль над средой выполнения скрипта, вы, вероятно, захотите вместо этого использовать метод run\_script() [API метаданных](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#metadata-api) объекта Distribution.
* iter\_entry\_points(group, name=None) - Получение объектов точки входа из группы group, совпадающей с name. Если name равно None, выдаются все точки входа в group из всех дистрибутивов в рабочем наборе, в противном случае выдаются только те точки входа, которые соответствуют как group, так и name. Точки входа получаются из активных распределений в том порядке, в котором распределения появляются в рабочем наборе. (Для глобального working\_set это должен быть тот же порядок, в котором они перечислены в sys.path.) Обратите внимание, что внутри точек входа, объявленных отдельным дистрибутивом, не существует определенного порядка. Дополнительную информацию см. в разделе «[Точки входа](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#tochki-vkhoda-entry-points)» ниже.

#### Методы и атрибуты WorkingSet

Эти методы используются для запроса или управления содержимым определенного рабочего набора, поэтому их необходимо явно вызывать для конкретного экземпляра WorkingSet:

* add\_entry(entry) - Добавляет в записи entries элемент пути, найдя по нему любые дистрибутивы. Вам следует использовать это, когда вы добавляете дополнительные элементы в sys.path и хотите, чтобы глобальный working\_set отражал эти изменения. Этот метод также вызывается конструктором WorkingSet() во время инициализации. Этот метод использует `find_distributions(entry, True)` для поиска дистрибутивов, соответствующих записи пути, а затем добавляет их add(). Однако entry всегда добавляется к атрибуту entries, даже если она уже присутствует. (Это связано с тем, что sys.path может содержать одно и то же значение более одного раза, и атрибут entries должен отражать это.)
* `__contains__(dist)` - True, если в этом рабочем наборе WorkingSet активно dist. Обратите внимание, что в данном WorjingSet может быть активен только один дистрибутив для данного проекта.
* `__iter__()` - Получение дистрибутивов для недублирующихся проектов в рабочем наборе. Порядок получения дистрибутивов — это порядок, в котором записи путей элементов были добавлены в рабочий набор.
* find(req) - Ищет запрос, соответствующий req (экземпляр Requirement). Если для запрошенного проекта существует активный дистрибутив, он возвращается, если он соответствует требованию к версии, указанному в req. Но если для проекта существует активный дистрибутив, который не соответствует требованию, возникает VersionConflict. Если для запрошенного проекта нет активного распространения, возвращается значение None.
* resolve(requirements, env=None, installer=None) - Список всех дистрибутивов, необходимых для (рекурсивного) удовлетворения требований requirements. Требования requirements должны представлять собой последовательность объектов Requirement. env, если он указан, должен быть экземпляром Environment. Если он не указан, среда создается из entries рабочего набора. Установщик installer, если он есть, будет вызываться при каждом требованию, которое не может быть выполнено уже установленным дистрибутивом; он должен вернуть Distribution или None. (Для получения дополнительной информации об аргументе installer см. метод obtain() [объектов среды](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#obekty-environment) ниже.)
* add(dist, entry=None) - Добавляет dist в рабочий набор, связанный с записью entry. Если entry не указана, по умолчанию используется dist.location. При выходе из этой процедуры entry добавляется в конец рабочего набора entries (если она еще не присутствовала). dist добавляется в рабочий набор только в том случае, если он предназначен для проекта, в наборе которого еще нет активного дистрибутива. Если он успешно добавлен, будут вызваны любые обратные вызовы, зарегистрированные с помощью метода subscribe(). (См. «[Получение уведомлений об изменениях](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#poluchenie-uvedomlenii-ob-izmeneniyakh)» ниже.) Примечание: add() автоматически вызывается методом require(), поэтому обычно вам не нужно использовать этот метод напрямую.

#### Получение уведомлений об изменениях

### Объекты Environment

### Объекты Requirement

#### Парсинг requirements

### Точки входа (Entry Points)

### Metadata API

### Поддержка пользовательских импортеров
