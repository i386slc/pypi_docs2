# Обнаружение пакета и доступ к ресурсам с pkg\_resources

Модуль pkg\_resources, распространяемый вместе с setuptools, предоставляет API для библиотек Python для доступа к их файлам ресурсов, а также для расширяемых приложений и платформ для автоматического обнаружения плагинов. Он также обеспечивает поддержку во время выполнения использования расширений C, находящихся внутри eggs-формата zip-файла, поддержку объединения пакетов, имеющих отдельно распространяемые модули или подпакеты, а также API для управления текущим «рабочим набором» активных пакетов Python.

{% hint style="danger" %}
Использование pkg\_resources устарело в пользу [importlib.resources](https://docs.python.org/3.11/library/importlib.resources.html#module-importlib.resources), [importlib.metadata](https://docs.python.org/3.11/library/importlib.metadata.html#module-importlib.metadata) и их бэкпортов ([importlib\_resources](https://pypi.org/project/importlib\_resources), [importlib\_metadata](https://pypi.org/project/importlib\_metadata)). Некоторые полезные API также предоставляются [packaging](https://pypi.org/project/packaging) (например, требования requirements и анализ версий). Пользователям следует воздерживаться от нового использования pkg\_resources и работать над портированием решений на основе importlib.
{% endhint %}

## Обзор

Модуль pkg\_resources предоставляет средства выполнения для поиска, анализа, активации и использования установленных дистрибутивов Python. Некоторые из более продвинутых функций (в частности, поддержка параллельной установки нескольких версий) основаны конкретно на формате "egg" (либо в виде zip-архива, либо в подкаталоге), в то время как другие (например, обнаружение плагинов) будут работать правильно, пока каталоги метаданных "egg-info" доступны для соответствующих дистрибутивов.

Eggs — это формат распространения модулей Python, по своей концепции схожий с "jars" Java или "gems" Ruby или форматом "wheel", определенным в PEP 427. Однако, в отличие от чистого формата распространения, eggs также можно устанавливать и добавлять напрямую в sys.path в качестве места импорта. При такой установке eggs доступны для обнаружения, а это означает, что они содержат метаданные, которые однозначно идентифицируют их содержимое и зависимости. Это означает, что установленное egg может быть автоматически найдено и добавлено в sys.path в ответ на простые запросы вида «принеси мне все, что мне нужно, чтобы использовать поддержку PDF в документах». Эта функция позволяет взаимно конфликтующим версиям дистрибутива сосуществовать в одной и той же установке Python, при этом отдельные приложения активируют нужную версию во время выполнения, манипулируя содержимым sys.path (это отличается от подхода к виртуальной среде, который предполагает создание изолированных сред для каждого приложения).

Для объяснения возможностей, предлагаемых этим модулем, необходимы следующие термины:

* project - Библиотека, платформа, скрипт, плагин, приложение или набор данных или других ресурсов или некоторая их комбинация. Предполагается, что проекты имеют «относительно уникальные» имена, например, имена, зарегистрированные с помощью PyPI.
* release - Снимок проекта в определенный момент времени, обозначаемый идентификатором версии.
* distribution - Файл или файлы, представляющие конкретный выпуск.
* importable distribution - Файл или каталог, который, если он помещен в sys.path, позволяет Python импортировать любые содержащиеся в нем модули.
* pluggable distribution - Импортируемый дистрибутив, имя файла которого однозначно идентифицирует его выпуск (т. е. проект и версию), а содержимое которого однозначно указывает, какие выпуски других проектов будут удовлетворять его требованиям времени выполнения.
* extra - это необязательная функция выпуска, которая может налагать дополнительные требования к времени выполнения. Например, если для поддержки PDF в docutils требуется наличие библиотеки поддержки PDF, docutils может определить поддержку PDF как дополнительную "extra" и перечислить, какие другие версии проекта должны быть доступны, чтобы ее обеспечить.
* environment - Коллекция дистрибутивов, потенциально доступных для импорта, но не обязательно активных. В среде может присутствовать более одного дистрибутива (т.е. версии выпуска) для данного проекта.
* working set - Коллекция дистрибутивов, фактически доступных для импорта, как в sys.path. В рабочем наборе может присутствовать не более одного дистрибутива (релизной версии) данного проекта, иначе возникнет неясность относительно того, что импортировать.
* eggs - это подключаемые дистрибутивы в одном из трех форматов, поддерживаемых в настоящее время pkg\_resources. Существуют built eggs, developmant eggs и eggs links. Built eggs — это каталоги или zip-файлы, имена которых заканчиваются на .egg и соответствуют соглашениям об именах eggs, и содержат подкаталог EGG-INFO (заархивированный или другой). Developmant eggs — это обычные каталоги кода Python с одним или несколькими подкаталогами ProjectName.egg-info. Формат developmant eggs также используется для предоставления версии дистрибутива по умолчанию, доступной программному обеспечению, которое не использует pkg\_resources для запроса определенных версий. Eggs links — это файлы \*.egg-link, которые содержат имя built или developmant egg для поддержки символических ссылок на платформах, которые не имеют собственных символических ссылок (или где поддержка символических ссылок ограничена).

Для получения дополнительной информации об этих терминах и концепциях см. также этот [архитектурный обзор](https://mail.python.org/pipermail/distutils-sig/2005-June/004652.html) pkg\_resources и Python Eggs в целом.

## Справочник по API

### Поддержка пакетов пространства имен

Пакет пространства имен — это пакет, который содержит только другие пакеты и модули и не имеет собственного содержимого. Такие пакеты можно разделить на несколько отдельно упакованных дистрибутивов. Обычно они используются для разделения больших пакетов, созданных одной организацией, например, в пакете пространства имен zope для пакетов Zope Corporation и в пакете пространства имен peak для Python Enterprise Application Kit.

Чтобы создать пакет пространства имен, вы указываете его в аргументе namespace\_packages функции setup() в файле setup.py вашего проекта. (Дополнительную информацию об этом см. в [документации по setuptools для пакетов пространства имен](rukovodstvo-polzovatelya-setuptools/obnaruzhenie-paketov-i-pakety-prostranstva-imen.md#poisk-paketov-prostranstva-imen)). Кроме того, необходимо добавить вызов declare\_namespace() в файл(ы) `__init__.py` пакета:

* declare\_namespace(name) - Объявляет, что имя пакета, разделенное точками, является «пакетом пространства имен», содержащиеся в нем пакеты и модули могут быть распределены по нескольким дистрибутивам. `__path__` именованного пакета будет расширен за счет включения соответствующего пакета во все дистрибутивы на sys.path, содержащие пакет с таким именем. (Точнее, если find\_module(name) импортера возвращает загрузчик, то он также будет искать содержимое пакета.) Всякий раз, когда вызывается метод active() дистрибутива, он проверяет наличие пакетов пространства имен и обновляет их содержимое `__path__` соответственно.

Приложениям, которые манипулируют пакетами пространства имен или напрямую изменяют sys.path во время выполнения, также может потребоваться использовать эту функцию API:

* fixup\_namespace\_packages(path\_item) - Объявляет, что path\_item — это новый элемент, добавленный в sys.path, который, возможно, потребуется использовать для обновления существующих пакетов пространства имен. Обычно это вызывается для вас, когда egg автоматически добавляется в sys.path, но если ваше приложение изменяет sys.path, чтобы включить местоположения, которые могут содержать части пакета пространства имен, вам нужно будет вызвать эту функцию, чтобы убедиться, что они добавлены. к существующим пакетам пространства имен.

Хотя по умолчанию pkg\_resources поддерживает только пакеты пространства имен для импортеров файловой системы и zip, вы можете расширить его поддержку для других «импортеров», совместимых с PEP 302, с помощью функции register\_namespace\_handler(). Подробности см. в разделе ниже «[Поддержка пользовательских импортеров](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#podderzhka-polzovatelskikh-importerov)».

### Объекты WorkingSet

Класс WorkingSet предоставляет доступ к коллекции «активных» дистрибутивов. В общем, существует только один значимый экземпляр рабочего набора: тот, который представляет дистрибутивы, которые в данный момент активны в sys.path. Этот глобальный экземпляр доступен под именем working\_set в модуле pkg\_resources. Однако специализированные инструменты могут захотеть манипулировать рабочими наборами, которые не соответствуют sys.path, и, следовательно, могут захотеть создать другие экземпляры WorkingSet.

Важно отметить, что глобальный объект working\_set инициализируется из sys.path при первом импорте pkg\_resources, но обновляется только в том случае, если вы выполняете все будущие манипуляции с sys.path через API pkg\_resources. Если вы вручную изменяете sys.path, вам необходимо вызвать соответствующие методы экземпляра working\_set, чтобы обеспечить его синхронизацию. К сожалению, Python не предоставляет никакого способа обнаружить произвольные изменения в объекте списка, таком как sys.path, поэтому pkg\_resources не может автоматически обновлять working\_set на основе изменений в sys.path.

* WorkingSet(entries=None) - Создает WorkingSet из итерации записей пути. Если entries не указаны, по умолчанию используется значение sys.path во время вызова конструктора. Обратите внимание, что обычно вы не создаете экземпляры WorkingSet самостоятельно, а вместо этого явно или неявно используете глобальный экземпляр working\_set. По большей части API pkg\_resources спроектирован так, что по умолчанию используется working\_set, так что вам не придется большую часть времени явно ссылаться на него.

Все дистрибутивы, доступные непосредственно в sys.path, будут активированы автоматически при импорте pkg\_resources. Такое поведение может вызвать конфликты версий для приложений, которым требуются версии этих дистрибутивов, отличные от версий по умолчанию. Чтобы справиться с этой ситуацией, pkg\_resources проверяет наличие атрибута `__requires__` в модуле `__main__` при инициализации рабочего набора по умолчанию и использует его, чтобы убедиться, что активирована подходящая версия каждого затронутого дистрибутива. Например:

```python
 # Должен быть установлен перед импортом pkg_resources
__requires__ = ["CherryPy < 3"]
import pkg_resources
```

#### Базовые методы WorkingSet

Следующие методы объектов WorkingSet также доступны как функции уровня модуля в pkg\_resources, которые применяются к экземпляру working\_set по умолчанию. Таким образом, вы можете использовать, например, pkg\_resources.require() как сокращение от pkg\_resources.working\_set.require():

* require(\*requirements) - Убедитесь, что дистрибутивы, соответствующие требованиям requirements, активированы. Требования requirements должны быть строкой или (возможно, вложенной) последовательностью, определяющей требуемые дистрибутивы и версии. Возвращаемое значение — это последовательность дистрибутивов, которые необходимо активировать для выполнения требований; включены все соответствующие дистрибутивы, даже если они уже были активированы в этом рабочем наборе. Синтаксис спецификаторов требований см. в разделе «[Парсинг требований](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#parsing-requirements)» ниже. В общем, вам не обязательно вызывать этот метод напрямую. Он предназначен больше для быстрого написания сценариев и взлома интерактивных интерпретаторов, чем для промышленного использования. Если вы создаете реальную библиотеку или приложение, настоятельно рекомендуется создать сценарий «setup.py» с помощью setuptools и объявить там все свои требования. Таким образом, такие инструменты, как pip, могут автоматически определять требования вашего пакета и соответствующим образом обрабатывать их. Обратите внимание, что вызов `require('SomePackage')` не установит SomePackage, если он еще не установлен. Если вам нужно это сделать, вместо этого вам следует использовать метод resolve(), который позволяет вам передать обратный вызов установщика, который будет вызываться, когда необходимый дистрибутив не может быть найден на локальном компьютере. Затем вы можете заставить этот обратный вызов отображать диалоговое окно, автоматически загружать необходимый дистрибутив или что-то еще, подходящее для вашего приложения. Дополнительную информацию см. в документации ниже по методу resolve(), а также по методу obtain() объектов Environment.
* run\_script(requires, script\_name) - Находит дистрибутив, указанный в списке requires, и запускает его сценарий script\_name. Параметр requires должен быть строкой, содержащей спецификатор требования. (Синтаксис см. ниже в разделе «[Парсинг требований](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#parsing-requirements)».) Скрипт, если он найден, будет выполнен в _глобальных переменных вызывающего объекта_. Это связано с тем, что этот метод предназначен для вызова из сценариев-оболочек, которые действуют как прокси для «настоящих» сценариев в дистрибутиве. Скрипту-оболочке обычно не нужно ничего делать, кроме вызова этой функции с правильными аргументами. Если вам нужен больший контроль над средой выполнения скрипта, вы, вероятно, захотите вместо этого использовать метод run\_script() [API метаданных](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#metadata-api) объекта Distribution.
* iter\_entry\_points(group, name=None) - Получение объектов точки входа из группы group, совпадающей с name. Если name равно None, выдаются все точки входа в group из всех дистрибутивов в рабочем наборе, в противном случае выдаются только те точки входа, которые соответствуют как group, так и name. Точки входа получаются из активных распределений в том порядке, в котором распределения появляются в рабочем наборе. (Для глобального working\_set это должен быть тот же порядок, в котором они перечислены в sys.path.) Обратите внимание, что внутри точек входа, объявленных отдельным дистрибутивом, не существует определенного порядка. Дополнительную информацию см. в разделе «[Точки входа](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#tochki-vkhoda-entry-points)» ниже.

#### Методы и атрибуты WorkingSet

Эти методы используются для запроса или управления содержимым определенного рабочего набора, поэтому их необходимо явно вызывать для конкретного экземпляра WorkingSet:

* add\_entry(entry) - Добавляет в записи entries элемент пути, найдя по нему любые дистрибутивы. Вам следует использовать это, когда вы добавляете дополнительные элементы в sys.path и хотите, чтобы глобальный working\_set отражал эти изменения. Этот метод также вызывается конструктором WorkingSet() во время инициализации. Этот метод использует `find_distributions(entry, True)` для поиска дистрибутивов, соответствующих записи пути, а затем добавляет их add(). Однако entry всегда добавляется к атрибуту entries, даже если она уже присутствует. (Это связано с тем, что sys.path может содержать одно и то же значение более одного раза, и атрибут entries должен отражать это.)
* `__contains__(dist)` - True, если в этом рабочем наборе WorkingSet активно dist. Обратите внимание, что в данном WorjingSet может быть активен только один дистрибутив для данного проекта.
* `__iter__()` - Получение дистрибутивов для недублирующихся проектов в рабочем наборе. Порядок получения дистрибутивов — это порядок, в котором записи путей элементов были добавлены в рабочий набор.
* find(req) - Ищет запрос, соответствующий req (экземпляр Requirement). Если для запрошенного проекта существует активный дистрибутив, он возвращается, если он соответствует требованию к версии, указанному в req. Но если для проекта существует активный дистрибутив, который не соответствует требованию, возникает VersionConflict. Если для запрошенного проекта нет активного распространения, возвращается значение None.
* resolve(requirements, env=None, installer=None) - Список всех дистрибутивов, необходимых для (рекурсивного) удовлетворения требований requirements. Требования requirements должны представлять собой последовательность объектов Requirement. env, если он указан, должен быть экземпляром Environment. Если он не указан, среда создается из entries рабочего набора. Установщик installer, если он есть, будет вызываться при каждом требованию, которое не может быть выполнено уже установленным дистрибутивом; он должен вернуть Distribution или None. (Для получения дополнительной информации об аргументе installer см. метод obtain() [объектов среды](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#obekty-environment) ниже.)
* add(dist, entry=None) - Добавляет dist в рабочий набор, связанный с записью entry. Если entry не указана, по умолчанию используется dist.location. При выходе из этой процедуры entry добавляется в конец рабочего набора entries (если она еще не присутствовала). dist добавляется в рабочий набор только в том случае, если он предназначен для проекта, в наборе которого еще нет активного дистрибутива. Если он успешно добавлен, будут вызваны любые обратные вызовы, зарегистрированные с помощью метода subscribe(). (См. «[Получение уведомлений об изменениях](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#poluchenie-uvedomlenii-ob-izmeneniyakh)» ниже.) Примечание: add() автоматически вызывается методом require(), поэтому обычно вам не нужно использовать этот метод напрямую.
* entries - Этот атрибут представляет собой «теневой» путь sys.path, который в первую очередь полезен для отладки. Если у вас возникли проблемы с импортом, вам следует проверить записи entries глобального объекта working\_set по sys.path, чтобы убедиться, что они совпадают. Если это не так, то какая-то часть вашей программы манипулирует sys.path без соответствующего обновления working\_set. ВАЖНОЕ ПРИМЕЧАНИЕ: не манипулируйте этим атрибутом напрямую! Установка его равным sys.path не решит вашу проблему, точно так же, как наложение черной ленты на индикатор «предупреждения двигателя» не исправит вашу машину! Если этот атрибут не синхронизирован с sys.path, это просто индикатор проблемы, а не ее причина.

#### Получение уведомлений об изменениях

Расширяемым приложениям и платформам может потребоваться получение уведомления, когда в рабочий набор добавляется новый дистрибутив (например, подключаемый модуль). Для этого предназначены метод subscribe() и функция add\_activation\_listener().

* subscribe(callback) - Вызывает callback(distribution) один раз для каждого активного распределения, которое находится в наборе сейчас или будет добавлено позже. Поскольку обратный вызов вызывается для уже активных дистрибутивов, вам не нужно самостоятельно перебирать рабочий набор для работы с существующими элементами; просто пропишите callback и будьте готовы к тому, что он будет вызван сразу этим методом. Обратите внимание, что обратные вызовы _**не должны**_ допускать распространения исключений, иначе они будут мешать работе других обратных вызовов и, возможно, приведут к несогласованному состоянию рабочего набора. Обратные вызовы должны использовать блок try/except для игнорирования, регистрации или иной обработки любых ошибок, особенно потому, что код, вызвавший вызов обратного вызова, вряд ли сможет обрабатывать ошибки лучше, чем сам обратный вызов.
* `pkg_resources.add_activation_listener()` - это альтернативное написание  `pkg_resources.working_set.subscribe()`

#### Поиск плагинов

Расширяемые приложения иногда имеют «каталог плагинов» или набор каталогов плагинов, из которых они хотят загружать точки входа или другие метаданные. Метод find\_plugins() позволяет вам сделать это, сканируя среду на предмет новейшей версии каждого проекта, которую можно безопасно загрузить без конфликтов или отсутствия требований.

* `find_plugins(plugin_env, full_env=None, fallback=True)` - Сканирует plugin\_env и определяет, какие дистрибутивы можно добавить в этот рабочий набор без конфликтов версий или отсутствия требований. Пример использования:

```python
distributions, errors = working_set.find_plugins(
    Environment(plugin_dirlist)
)
map(working_set.add, distributions)  # добавление plugins+libs в sys.path
print "Couldn't load", errors        # отображение ошибок
```

plugin\_env должен быть экземпляром среды Environment, который содержит только те дистрибутивы, которые находятся в «каталоге плагинов» или каталогах проекта. full\_env, если он указан, должен быть экземпляром Environment, содержащим все доступные на данный момент дистрибутивы.

Если full\_env не указан, он создается автоматически из рабочего набора, из которого вызывается этот метод, что обычно означает, что каждый каталог в sys.path будет сканироваться на наличие дистрибутивов.

Этот метод возвращает кортеж из двух элементов: (distributions, error\_info), где distributions — это список дистрибутивов, найденных в plugin\_env, которые можно было загрузить, а также любые другие дистрибутивы, необходимые для разрешения их зависимостей. error\_info — это словарь, сопоставляющий дистрибутивы выгружаемых плагинов с экземпляром исключения, описывающим произошедшую ошибку. Обычно это экземпляр DistributionNotFound или VersionConflict.

Большинство приложений будут использовать этот метод в основном для главного экземпляра working\_set в pkg\_resources, а затем немедленно добавлять возвращаемые дистрибутивы в рабочий набор, чтобы они были доступны в sys.path. Это позволит найти любые точки входа и активировать любое другое отслеживание метаданных и перехваты.

Алгоритм разрешения, используемый find\_plugins(), следующий. Сначала сортируются имена проектов дистрибутивов, присутствующих в plugin\_env. Затем eggs каждого проекта проверяются в порядке убывания версий (т. е. сначала самая новая версия).

Предпринимается попытка разрешить зависимости каждого eggs. Если попытка успешна, egg и его зависимости добавляются в выходной список и во временную копию рабочего набора. Процесс разрешения продолжается со следующим именем проекта, и более старые eggs для этого проекта не рассматриваются.

Однако если попытка разрешения не удалась, ошибка добавляется в словарь ошибок. Если флаг возврата имеет значение true, пробуется следующая более старая версия плагина, пока не будет найдена рабочая версия. Если false, процесс разрешения продолжается со следующим именем проекта плагина.

Некоторые приложения могут иметь более строгие требования к резервному использованию, чем другие. Например, приложение, имеющее схему базы данных или постоянные объекты, может не иметь возможности безопасно понизить версию пакета. Другие могут захотеть убедиться, что новая конфигурация плагина либо на 100% хороша, либо вернуться к заведомо исправной конфигурации. (То есть они могут захотеть вернуться к известной конфигурации, если возвращаемое значение error\_info не пусто.)

Обратите внимание, что этот алгоритм отдает приоритет удовлетворению зависимостей имен проектов в алфавитном порядке в случае конфликтов версий. Если двум проектам с именами «AaronsPlugin» и «ZekesPlugin» нужны разные версии «TomsLibrary», то «AaronsPlugin» выиграет, а «ZekesPlugin» будет отключен из-за конфликта версий.

### Объекты Environment

Среда "environment" — это набор объектов Distribution, обычно тех, которые присутствуют и потенциально могут быть импортированы на текущей платформе. Объекты Environment используются pkg\_resources для индексации доступных дистрибутивов во время разрешения зависимостей.

* `Environment(search_path=None, platform=get_supported_platform(), python=PY_MAJOR)` - Создает снапшот среды, просканировав search\_path на наличие дистрибутивов, совместимых с платформой и Python. search\_path должен представлять собой последовательность строк, например, которая может использоваться в sys.path. Если search\_path не указан, используется sys.path. platform — необязательная строка, определяющая имя платформы, с которой должны быть совместимы дистрибутивы для конкретной платформы. Если не указано, по умолчанию используется текущая платформа. python — необязательная строка, указывающая желаемую версию Python (например, "2.4"); по умолчанию используется текущая версия. Вы можете явно установить для platform (и/или Python) значение None, если хотите включить все дистрибутивы, а не только те, которые совместимы с работающей платформой или версией Python. Обратите внимание, что search\_path немедленно сканируется на наличие дистрибутивов, и результирующая Environment представляет собой снимок найденных дистрибутивов. Он не обновляется автоматически, если состояние системы изменяется, например, по причине установки или удаления дистрибутивов.
* `__getitem__(project_name)` - Возвращает список дистрибутивов для данного имени проекта, упорядоченный от самой новой к самой старой версии. (И приоритет формата от самого высокого до самого низкого для дистрибутивов, содержащих одну и ту же версию проекта.) Если для проекта нет дистрибутивов, возвращается пустой список.
* `__iter__()` - Получение уникальных имен проектов дистрибутивов в этой среде. Полученные имена всегда пишутся строчными буквами.
* `add(dist)` - Добавляет dist в среду, если он соответствует платформе и версии Python, указанным во время создания, и только если дистрибутив еще не был добавлен. (т.е. добавление одного и того же дистрибутива более одного раза недопустимо.)
* `remove(dist)` - Удаляет dist из среды.
* `can_add(dist)` - Приемлемо ли добавление dist для этой среды? Если оно несовместимо со значениями платформы и версии Python, указанными при создании среды, возвращается ложное значение.
* `__add__(dist_or_env)` (`+` operator) - Добавляет дистрибутив или среду в экземпляр Environment, возвращая _**новый**_ объект среды, содержащий все дистрибутивы, ранее содержащиеся в обоих. Новая среда будет иметь platform и python со значением None, что означает, что она не будет отклонять добавление в нее каких-либо дистрибутивов; он просто примет все, что будет добавлено. Если вы хотите, чтобы добавленные элементы фильтровались по платформе и версии Python или вы хотите добавить их в _**один и тот же**_ экземпляр среды, вместо этого следует использовать добавление на месте (`+=`).
* `__iadd__(dist_or_env)` (`+=` operator) - Добавляет дистрибутив или среду в экземпляр Environment на месте, обновив существующий экземпляр и вернув его. Атрибуты фильтра platform и python вступают в силу, поэтому дистрибутивы в исходном коде, у которых нет подходящей строки платформы или версии Python, игнорируются.
* `best_match(req, working_set, installer=None)` - Ищет наиболее подходящий req для дистрибутива, который можно использовать на working\_set. При этом вызывается метод find(req) working\_set, чтобы проверить, активен ли уже подходящий дистрибутив. (Это может вызвать конфликт версий VersionConflict, если неподходящая версия проекта уже активна в указанном working\_set.) Если подходящий дистрибутив не активен, этот метод возвращает новейший дистрибутив в среде, соответствующий Requirement в req. Если подходящий дистрибутив не найден и предоставлен установщик, то будет возвращен результат вызова метода obtain(req, installer) среды.
* `obtain(requirement, installer=None)` - Получает дистрибутив, соответствующий требованиям (например, через загрузку). В базовом классе Environment эта процедура просто возвращает installer(requirement), если только installer не имеет значения None, и в этом случае вместо него возвращается None. Этот метод представляет собой хук, который позволяет подклассам попробовать другие способы получения дистрибутива, прежде чем вернуться к аргументу установщика.
* `scan(search_path=None)` - Сканирует search\_path на наличие дистрибутивов, которые можно использовать на платформе platform. Все найденные дистрибутивы добавляются в среду. search\_path должен представлять собой последовательность строк, например, которая может использоваться в sys.path. Если он не указан, используется sys.path. Добавляются только дистрибутивы, соответствующие версии платформы/Python, определенной при инициализации. Этот метод представляет собой сокращенный вариант использования функции find\_distributions() для поиска распределений каждого элемента в search\_path, а затем вызова add() для добавления каждого из них в среду.

### Объекты Requirement

Объекты Requirement выражают, какие версии проекта подходят для той или иной цели. Эти объекты (или их строковая форма) используются различными API-интерфейсами pkg\_resources для поиска дистрибутивов, необходимых сценарию или дистрибутиву.

#### Парсинг requirements

* `parse_requirements(s)` - Возвращает объекты Requirement для строки или итерации строк. Каждое требование должно начинаться с новой строки. Синтаксис см. ниже.
* `Requirement.parse(s)` - Создает объект Requirement из строки или итерации строк. Ошибка ValueError возникает, если строка или строки не содержат допустимого спецификатора требования или содержат более одного спецификатора. (Чтобы проанализировать несколько спецификаторов из строки или итерации строк, используйте вместо этого parse\_requirements().) Синтаксис спецификатора требования полностью определен в PEP 508. Некоторые примеры допустимых спецификаторов требований:

```python
FooProject >= 1.2
Fizzy [foo, bar]
PickyThing>1.6,<=1.9,!=1.8.6
SomethingWhoseVersionIDontCareAbout
SomethingWithMarker[foo]>1.0;python_version<"2.7"
```

Имя проекта — единственная обязательная часть строки требования, и если это единственное, что указано, требование будет принимать любую версию этого проекта.

"extras" в требовании используются для запроса дополнительных функций проекта, для работы которых могут потребоваться дополнительные дистрибутивы проекта. Например, если бы гипотетический проект «Report-O-Rama» предлагал дополнительную поддержку PDF, для обеспечения такой поддержки могла бы потребоваться дополнительная библиотека. Таким образом, проект, которому необходимы функции PDF Report-O-Rama, может использовать требование `Report-O-Rama[PDF]` для запроса установки или активации как Report-O-Rama, так и любых библиотек, которые ему необходимы для обеспечения поддержки PDF. Например, вы можете использовать:

```bash
pip install Report-O-Rama[PDF]
```

Чтобы установить необходимые пакеты, используйте pip или вызовите pkg\_resources.require('Report-O-Rama\[PDF]'), чтобы добавить необходимые дистрибутивы в sys.path во время выполнения.

«Маркеры» в требовании используются для указания того, когда требование должно быть установлено — требование будет установлено, если маркер оценивается как истинный в текущей среде. Например, указание `argparse;python_version<"3.0"` не будет установлено в среде Python 3, но будет установлено в среде Python 2.

#### Методы и атрибуты Requirment

* `__contains__(dist_or_version)` - Возвращает true, если dist\_or\_version соответствует критериям этого требования. Если dist\_or\_version является объектом Distribution, имя его проекта должно совпадать с именем проекта требования, а его версия должна соответствовать критериям версии требования. Если dist\_or\_version представляет собой строку, она анализируется с помощью служебной функции parse\_version(). В противном случае предполагается, что это уже проанализированная версия. Спецификаторы версий объекта Requirement (.specs) внутренне сортируются по возрастанию версий и используются для определения допустимых диапазонов версий. Соседние избыточные условия эффективно объединяются (например, `">1, >2"` дает те же результаты, что и `">2"`, а `"<2,<3"` дает те же результаты, что и `"<2"`). Версии `"!="` исключаются из диапазонов, в которые они попадают. Версия, проверяемая на приемлемость, затем проверяется на членство в результирующих диапазонах.
* `__eq__(other_requirement)` - Требование сравнивается с другим требованием, если они имеют одинаковые имена проектов, спецификаторы версий и "extras" без учета регистра. (Порядок, в котором указаны дополнительные элементы и спецификаторы версий, также игнорируется.) Равные требования также имеют равные хэши, поэтому требования можно использовать в наборах или в качестве ключей словаря.
* `__str__()` - Строковая форма Requirement — это строка, которая при передаче в Requirement.parse() вернет равный объект Requirement.
* `project_name` - Название необходимого проекта
* `key` - Версия project\_name, написанная только строчными буквами, полезная для сравнения или индексирования.
* `extras` - Кортеж имен "extras", которые требует это требование. (Они будут написаны строчными буквами и нормализованы с помощью служебной функции синтаксического анализа `safe_extra()`, поэтому они могут не в точности соответствовать дополнительным параметрам, с которыми было создано требование.)
* `specs` - Список кортежей `(op,version)`, отсортированных в порядке возрастания проанализированной версии. **op** в каждом кортеже — это оператор сравнения, представленный в виде строки. **version** — это (неанализируемый) номер версии.
* `marker` - Экземпляр `package.markers.Marker`, который позволяет оценивать текущую среду. Может быть None, если маркер не указан.
* `url` - Местоположение для загрузки требования, если оно указано.

### Точки входа (Entry Points)

Точки входа — это простой способ «рекламировать» объекты Python (такие как функции или классы) для использования другими дистрибутивами. Расширяемые приложения и платформы могут искать точки входа с определенным именем или группой либо из определенного дистрибутива, либо из всех активных дистрибутивов по sys.path, а затем проверять или загружать объявленные объекты по своему желанию.

Точки входа принадлежат "groups", имена которых разделены точками, аналогично имени пакета или модуля Python. Например, пакет setuptools использует точку входа с именем `distutils.commands` для поиска команд, определенных расширениями distutils. **setuptools** рассматривает имена точек входа, определенные в этой группе, как допустимые команды для сценария установки.

Аналогичным образом другие пакеты могут определять свои собственные группы точек входа, либо используя динамические имена внутри группы (например, `distutils.commands`), либо, возможно, используя предопределенные имена внутри группы. Например, платформа ведения блога, предлагающая различные перехватчики до или после публикации, может определить группу точек входа и искать точки входа с именами `"pre_process"` и `"post_process"` внутри этой группы.

Чтобы объявить точку входа, проекту необходимо использовать setuptools и предоставить аргумент entry\_points функции `setup()` в своем скрипте установки, чтобы точки входа были включены в метаданные дистрибутива. Более подробную информацию см. в разделе «[Поведение рекламы](rukovodstvo-polzovatelya-setuptools/tochki-vkhoda-entry-poynts.md#reklamnoe-povedenie)».

Каждый дистрибутив проекта может рекламировать не более одной точки входа с заданным именем в одной группе точек входа. Например, расширение distutils может объявлять две разные точки входа `distutils.commands`, если они имеют разные имена. Однако нет ничего, что мешает _**разным**_ проектам рекламировать одноимённые точки входа в одной группе. В некоторых случаях это желательно, поскольку приложение или платформа, использующая точки входа, может вызывать их как перехватчики или каким-либо другим образом комбинировать их. Приложение или платформа должны решить, что делать, если несколько дистрибутивов объявляют точку входа; некоторые возможности включают использование обеих точек входа, отображение сообщения об ошибке, использование первой точки, найденной в порядке sys.path, и т. д.

#### Удобный API

В следующих функциях аргумент dist может быть экземпляром Distribution, экземпляром Requirement или строкой, определяющей требование (т.е. имя проекта, версию и т. д.). Если аргументом является строка или требование, указанный дистрибутив находится (и добавляется в sys.path, если он еще не существует). Если соответствующий дистрибутив недоступен, возникнет ошибка.

Аргумент группы group должен представлять собой строку, содержащую точечный идентификатор, идентифицирующий группу точек входа. Если вы определяете группу точек входа, вам следует включить некоторую часть имени вашего пакета в имя группы, чтобы избежать конфликта с группами точек входа других пакетов.

* `load_entry_point(dist, group, name)` - Загружает именованную точку входа из указанного дистрибутива или вызывает ImportError.
* `get_entry_info(dist, group, name)` - Возвращает объект EntryPoint для данной группы group и имени name из указанного дистрибутива. Возвращает None, если распределение dist не объявило соответствующую точку входа.
* `get_entry_map(dist, group=None)` - Возвращает карту точек входа дистрибутива для группы group или полную карту входа для дистрибутива. Эта функция всегда возвращает словарь, даже если дистрибутив не объявляет никаких точек входа. Если указана группа, словарь сопоставляет имена точек входа соответствующему объекту EntryPoint. Если группа group имеет значение None, словарь сопоставляет имена групп словарям, которые затем сопоставляют имена точек входа с соответствующим экземпляром EntryPoint в этой группе.
* `iter_entry_points(group, name=None)` - Выдает объекты точки входа из группы group, совпадающей с именем name. Если name равно None, выдаются все точки входа в группе из всех дистрибутивов в рабочем наборе по sys.path, в противном случае выдаются только те точки входа, которые соответствуют как группе group, так и имени name. Точки входа получаются из активных раздач в том порядке, в котором они появляются в sys.path. (Однако внутри точек входа для конкретного дистрибутива нет определенного порядка.) (Этот API на самом деле является методом глобального объекта working\_set; дополнительную информацию см. в разделе «[Основные методы WorkingSet](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#bazovye-metody-workingset)» выше.)

#### Создание и синтаксический анализ

* `EntryPoint(name, module_name, attrs=(), extras=(), dist=None)` - Создает экземпляр EntryPoint. name — имя точки входа. module\_name — это (точечное) имя модуля, содержащего рекламируемый объект. attrs — это необязательный кортеж имен, который нужно найти в модуле для получения объявленного объекта. Например, атрибуты («foo», «bar») и module\_name «baz» означают, что рекламируемый объект можно получить с помощью следующего кода:

```python
import baz
advertised_object = baz.foo.bar
```

extras — это необязательный кортеж имен «дополнительных функций», которые необходимы дистрибутиву для предоставления этой точки входа. Когда точка входа загружается, эти дополнительные функции просматриваются в аргументе dist, чтобы выяснить, какие еще дистрибутивы необходимо активировать в sys.path; более подробную информацию см. в методе `load()`. Аргумент extras имеет смысл только в том случае, если указано dist. dist должен быть экземпляром Distribution.

* `EntryPoint.parse(src, dist=None)` (classmethod) - Анализ одной точки входа из строки src. Синтаксис точки входа имеет следующий вид:

```python
name = some.module:some.attr [extra1,extra2]
```

Имя записи и имя модуля являются обязательными, но части `:attrs` и `[extras]` не являются обязательными, как и пробелы, отображаемые между некоторыми элементами. Аргумент dist передается конструктору `EntryPoint()` вместе с другими значениями, полученными из src.

* `EntryPoint.parse_group(group, lines, dist=None)` (classmethod) - Анализирует строки lines (строку или последовательность строк) для создания словаря, сопоставляющего имена точек входа с объектами EntryPoint. ValueError возникает, если имена точек входа дублируются, если группа не является допустимым именем группы точек входа или имеются какие-либо синтаксические ошибки. (Примечание: параметр group используется только для проверки и создания более информативных сообщений об ошибках.) Если указан dist, он будет использоваться для установки атрибута dist созданных объектов EntryPoint.
* `EntryPoint.parse_map(data, dist=None)` (classmethod) - Синтаксический анализ data в словаре, сопоставляющем имена групп со словарями, сопоставляющими имена точек входа с объектами EntryPoint. Если data представляет собой словарь, то ключи используются как имена групп, а значения передаются в функцию `parse_group()` в качестве аргумента lines. Если data представляет собой строку или последовательность строк, они сначала разбиваются на разделы в стиле `.ini` (с помощью служебной функции `split_sections()`), а имена разделов используются в качестве имен групп. В любом случае аргумент dist передается в функцию `parse_group()`, чтобы точки входа были связаны с указанным распределением.

#### Объекты EntryPoint

Для простого самоанализа объекты EntryPoint имеют атрибуты, которые точно соответствуют именам аргументов конструктора: доступны все name, module\_name, attrs, extras и dist. Кроме того, предусмотрены следующие методы:

* `load()` - Загружает точку входа, вернув объявленный объект Python. Фактически вызывает `self.require()`, а затем возвращает `self.resolve()`.
* `require(env=None, installer=None)` - Убедитесь, что все дополнительные "extras", необходимые для точки входа, доступны в sys.path. UnknownExtra возникает, если EntryPoint имеет extras, но не имеет dist, или если именованные дополнительные функции не определены в дистрибутиве. Если указан env, это должна быть среда Environment, и она будет использоваться для поиска необходимых дистрибутивов, если они еще не присутствуют в sys.path. Если указан установщик installer, он должен быть вызываемым объектом, принимающим экземпляр Requirement и возвращающим соответствующий импортируемый экземпляр Distribution или None.
* `resolve()` - Разрешает точку входа из его модуля и атрибутов, вернув объявленный объект Python. Вызывает ImportError, если его невозможно получить.
* `__str__()` - Строковая форма EntryPoint — это строка, которую можно передать в `EntryPoint.parse()` для создания эквивалентной EntryPoint.

### Объекты Distribution

Объекты Distribution представляют собой коллекции кода Python, которые могут быть или не быть импортируемыми, и могут иметь или не иметь связанные с ними метаданные и ресурсы. Их метаданные могут включать в себя такую информацию, как, например, от каких других проектов зависит дистрибутив, какие точки входа рекламирует дистрибутив и т. д.

#### Получение и создание Distribution

Чаще всего вы получаете объекты Distribution из рабочего набора WorkingSet или среды Environmant. (См. разделы выше об [объектах WorkingSet](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#obekty-workingset) и [объектах Environmant](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#obekty-environment), которые являются контейнерами для активных и доступных дистрибутивов соответственно.) Вы также можете получить объекты Distribution из одного из этих API высокого уровня:

* `find_distributions(path_item, only=False)` - возвращает дистрибутивы, доступные через path\_item. Если значение only истинно, выдает только те дистрибутивы, местоположение которых равно path\_item. Другими словами, если только это верно, это дает любые дистрибутивы, которые можно было бы импортировать, если бы path\_item находился в sys.path. Если значение only равно false, это также дает дистрибутивы, которые находятся «в» или «под» path\_item, но их нельзя будет импортировать, если их местоположения также не будут добавлены в sys.path.
* `get_distribution(dist_spec)` - Возвращает объект Distribution для данного требования Requirement или строки. Если dist\_spec уже является экземпляром Distribution, он возвращается. Если это объект Requirement или строка, которую можно разобрать на один объект, он используется для поиска и активации соответствующего дистрибутива, который затем возвращается.

Однако если вы создаете специализированные инструменты для работы с дистрибутивами или создаете новый формат дистрибутива, вам также может потребоваться создать объекты Distribution напрямую, используя один из трех конструкторов ниже.

Все эти конструкторы принимают необязательный аргумент metadata, который используется для доступа к любым ресурсам или метаданным, связанным с дистрибутивом. Метаданные metadata должны быть объектом, реализующим интерфейс IResourceProvider, или None. Если оно равно None, вместо него используется EmptyProvider. Объекты распространения реализуют методы [IResourceProvider](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#iresourceprovider) и [IMetadataProvider](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#metody-imetadataprovider), делегируя их объекту metadata.

* `Distribution.from_location(location, basename, metadata=None, **kw)` (classmethod) - создает дистрибутив для location, который должно быть строкой, например URL-адресом, именем файла или другой строкой, которая может использоваться в sys.path. basename — это строка, именующая дистрибутив, например `Foo-1.2-py2.4.egg`. Если basename заканчивается на `.egg`, то имя проекта, версия, версия Python и платформа извлекаются из имени файла и используются для установки этих свойств созданного дистрибутива. Любые дополнительные аргументы ключевого слова передаются конструктору `Distribution()`.
* `Distribution.from_filename(filename, metadata=None**kw)` (classmethod) - создает дистрибутив, проанализировав локальное имя файла. Это более короткий способ сказать `Distribution.from_location(normalize_path(filename), os.path.basename(filename), metadata`). Другими словами, он создает дистрибутив, местоположение которого представляет собой нормализованную форму имени файла, анализируя имя и информацию о версии из базовой части имени файла. Любые дополнительные аргументы ключевого слова передаются конструктору `Distribution()`.
* `Distribution(location,metadata,project_name,version,py_version,platform,precedence)` - создает дистрибутив, задав его свойства. Все аргументы являются необязательными и по умолчанию имеют значение None, за исключением py\_version (которое по умолчанию соответствует текущей версии Python) и precedence (которое по умолчанию равно EGG\_DIST; более подробную информацию см. в precedence в разделе «[Атрибуты Distribution](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#atributy-distribution)» ниже). Обратите внимание, что обычно проще использовать конструкторы `from_filename()` или `from_location()`, чем указывать все эти аргументы по отдельности.

#### Атрибуты Distribution

* `location` - Строка, указывающая расположение дистрибутива. Для импортируемого дистрибутива эта строка будет добавлена в sys.path, чтобы сделать его доступным для активного импорта. Для неимпортируемых дистрибутивов это просто имя файла, URL-адрес или другой способ найти дистрибутив.
* `project_name` - Строка с именем проекта, для которого предназначен этот дистрибутив. Имена проектов определяются сценарием установки проекта и используются для идентификации проектов в PyPI. При создании Distribution аргумент project\_name передается через служебную функцию `safe_name()` для фильтрации любых недопустимых символов.
* `key` - `dist.key` — это сокращение от `dist.project_name.lower()`. Он используется для сравнения без учета регистра и индексации дистрибутивов по имени проекта.
* `extras` - Список строк, дающих имена дополнительных функций, определенных списком зависимостей проекта (аргумент extras\_require, указанный в скрипте установки проекта).
* `version` - Строка, обозначающая, какую версию проекта содержит этот дистрибутив. При создании дистрибутива Distribution аргумент version передается через служебную функцию `safe_version()` для фильтрации любых недопустимых символов. Если во время создания version не указана, то попытка доступа к этому атрибуту позже приведет к тому, что дистрибутив Distribution попытается обнаружить его версию, прочитав файл метаданных PKG-INFO. Если PKG-INFO недоступен или не может быть проанализирован, возникает ValueError.
* `parsed_version` - это объект, представляющий «проанализированную» форму версии дистрибутива. `dist.parsed_version` — это ярлык для вызова `parse_version(dist.version)`. Он используется для сравнения или сортировки дистрибутивов по версиям. (Дополнительную информацию о функции `parse_version()` см. в разделе «[Утилиты синтаксического анализа](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#utility-sintaksicheskogo-analiza)» ниже.) Обратите внимание, что доступ к parsed\_version может привести к ошибке ValueError, если дистрибутив Distribution был создан без версии version и без метаданных metadata, способных предоставить недостающую информацию о версии.
* `py_version` - Основная/дополнительная версия Python, поддерживаемая дистрибутивом, в виде строки. Например, "2.7" или "3.4". По умолчанию используется текущая версия Python.
* `platform` - Строка, представляющая платформу, для которой предназначен дистрибутив, или None, если дистрибутив является «чистым Python» и, следовательно, кроссплатформенным. Дополнительную информацию о строках платформы см. ниже в разделе «[Утилиты платформы](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#utility-platformy)».
* `precedence` - Приоритет дистрибутива используется для определения относительного порядка двух дистрибутивов, имеющих одинаковые project\_name и parsed\_version. Приоритет по умолчанию — `pkg_resources.EGG_DIST`, который является самым высоким (т.е. наиболее предпочтительным) приоритетом. Полный список предопределенных приоритетов, от наиболее предпочтительного до наименее предпочтительного, выглядит следующим образом: EGG\_DIST, BINARY\_DIST, SOURCE\_DIST, CHECKOUT\_DIST и DEVELOP\_DIST. Обычно приоритеты, отличные от EGG\_DIST, используются только модулем `setuptools.package_index` при сортировке дистрибутивов, найденных в индексе пакета, для определения их пригодности для установки. Однако egg "System" и "Development" (т.е. те, которые используют формат `.egg-info`) автоматически получают приоритет DEVELOP\_DIST.

#### Методы Distribution

* `activate(path=None)` - Убедитесь, что дистрибутив можно импортировать по пути. Если путь равен None, вместо него используется sys.path. Это гарантирует, что расположение location дистрибутива находится в списке путей path, а также выполняет все необходимые исправления или объявления пакета пространства имен. (То есть, если дистрибутив содержит пакеты пространства имен, этот метод гарантирует, что они объявлены и что содержимое дистрибутива для этих пакетов пространства имен объединяется с содержимым, предоставленным любыми другими активными дистрибутивами. Дополнительную информацию см. в разделе «[Поддержка пакетов пространства имен](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#podderzhka-paketov-prostranstva-imen)» выше. информация.) pkg\_resources добавляет обратный вызов уведомления в глобальный working\_set, который гарантирует вызов этого метода всякий раз, когда к нему добавляется дистрибутив. Поэтому обычно вам не нужно явно вызывать этот метод. (Обратите внимание, что это означает, что пакеты пространства имен в sys.path всегда импортируются сразу же после импорта pkg\_resources, что является еще одной причиной, по которой пакеты пространства имен не должны содержать никакого кода или операторов импорта.)
* `as_requirement()` - Возвращает экземпляр Requirement, соответствующий имени и версии проекта этого дистрибутива.
* `requires(extras=())` - Список объектов Requirement, которые определяют зависимости этого дистрибутива. Если указаны дополнительные возможности extras, это должна быть последовательность имен "extras", определенных дистрибутивом, а возвращаемый список будет включать в себя все зависимости, необходимые для поддержки названных "extras".
* `clone(**kw)` - Создает копию дистрибутива. Любые предоставленные аргументы ключевого слова переопределяют соответствующий аргумент конструктора `Distribution()`, что позволяет вам изменить некоторые атрибуты скопированного дистрибутива.
* `egg_name()` - Возвращает стандартное имя файла этого дистрибутива, не включая расширение `".egg"`. Например, дистрибутив проекта `"Foo"` версии 1.2, работающий на Python 2.3 для Windows, будет иметь `egg_name()` типа `Foo-1.2-py2.3-win32`. Любые тире в имени или версии преобразуются в подчеркивания. (`Distribution.from_location()` преобразует их обратно при анализе имени файла `".egg"`.)
* `__cmp__(other)`, `__hash__()` - Объекты Distribution хешируются и сравниваются на основе их проанализированной версии и приоритета, за которыми следует их ключ (имя проекта в нижнем регистре), местоположение, версия Python и платформа.

Следующие методы используются для доступа к объектам EntryPoint, рекламируемым дистрибутивом. См. раздел «[Точки входа](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#tochki-vkhoda-entry-points)» выше для получения более подробной информации об этих операциях:

* `get_entry_info(group, name)` - Возвращает объект EntryPoint для группы и имени или None, если такая точка не объявлена этим дистрибутивом.
* `get_entry_map(group=None)` - Возвращает карту точки входа для группы group. Если группа group имеет значение None, возвращает имена групп сопоставления словаря в карты точек входа для всех групп. (Карта точек входа — это словарь имен точек входа в объекты EntryPoint.)
* `load_entry_point(group, name)` - Сокращение от `get_entry_info(group, name).load()`. Возвращает объект, объявленный именованной точкой входа, или выдает ImportError, если точка входа не объявлена этим дистрибутивом или существует какая-либо другая проблема с импортом.

В дополнение к вышеуказанным методам объекты Distribution также реализуют все методы [IResourceProvider](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#iresourceprovider) и [IMetadataProvider](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#metody-imetadataprovider) (которые описаны в последующих разделах):

* `has_metadata(name)`
* `metadata_isdir(name)`
* `metadata_listdir(name)`
* `get_metadata(name)`
* `get_metadata_lines(name)`
* `run_script(script_name, namespace)`
* `get_resource_filename(manager, resource_name)`
* `get_resource_stream(manager, resource_name)`
* `get_resource_string(manager, resource_name)`
* `has_resource(resource_name)`
* `resource_isdir(resource_name)`
* `resource_listdir(resource_name)`

Если дистрибутив был создан с аргументом metadata, все эти методы доступа к ресурсам и метаданным делегируются этому поставщику метаданных. В противном случае они делегируются EmptyProvider, так что в дистрибутиве не будет ресурсов или метаданных. Этот подход делегирования используется для того, чтобы поддержку пользовательских импортеров или новых форматов распространения можно было осуществлять просто путем создания соответствующей реализации [IResourceProvider](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#iresourceprovider); дополнительные сведения см. в разделе ниже «[Поддержка пользовательских импортеров](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#podderzhka-polzovatelskikh-importerov)».

### ResourceManager API

Класс ResourceManager обеспечивает единый доступ к ресурсам пакета, независимо от того, существуют ли эти ресурсы в виде файлов и каталогов или сжаты в каком-либо архиве.

Обычно вам не нужно создавать или явно управлять экземплярами ResourceManager, поскольку модуль pkg\_resources создает для вас глобальный экземпляр и делает большинство своих методов доступными в виде имен верхнего уровня в пространстве имен модуля pkg\_resources. Так, например, этот код фактически вызывает метод `resources_string()` глобального ResourceManager:

```python
import pkg_resources
my_data = pkg_resources.resource_string(__name__, "foo.dat")
```

Таким образом, вы можете использовать приведенные ниже API без необходимости явного экземпляра ResourceManager; просто импортируйте и используйте их по мере необходимости.

#### Базовый доступ к ресурсам

В следующих методах аргумент package\_or\_requirement может быть либо именем пакета/модуля Python (например, `foo.bar`), либо экземпляром Requirement. Если это имя пакета или модуля, указанный модуль или пакет должен быть импортируемым (т. е. находиться в дистрибутиве или каталоге на `sys.path`), а аргумент resource\_name интерпретируется относительно именованного пакета. (Обратите внимание, что если используется имя модуля, то имя ресурса указывается относительно пакета, непосредственно содержащего указанный модуль. Кроме того, не следует использовать имя пакета пространства имен, поскольку пакет пространства имен может быть распределен по нескольким дистрибутивам и поэтому неясно, в каком дистрибутиве следует искать ресурс.)

Если это Requirement, то требование автоматически разрешается (при необходимости выполняется поиск в текущей среде Environmant), и соответствующий дистрибутив добавляется в WorkingSet и sys.path, если он еще не присутствовал. (Если только Requirement не может быть удовлетворено, в этом случае возникает исключение.) Аргумент resource\_name затем интерпретируется относительно корня идентифицированного дистрибутива; т.е. его первый сегмент пути будет рассматриваться как одноранговый модуль или пакеты верхнего уровня в дистрибутиве.

Обратите внимание, что имена ресурсов должны быть путями, разделенными символами `/`, расположенными в пакете, не могут содержать относительные имена, такие как `".."`, и не могут быть абсолютными. _**Не используйте**_ процедуры `os.path` для управления путями ресурсов, поскольку они _**не являются**_ путями файловой системы.

* `resource_exists(package_or_requirement, resource_name)` - Существует ли указанный ресурс? Возвращает True или False соответственно.
* `resource_stream(package_or_requirement, resource_name)` - Возвращает читаемый файлоподобный объект для указанного ресурса; это может быть реальный файл, StringIO или какой-либо подобный объект. Поток находится в «двоичном режиме» в том смысле, что любые байты в ресурсе будут прочитаны как есть.
* `resource_string(package_or_requirement, resource_name)` - Возвращает указанный ресурс как bytes. Ресурс считывается в двоичном виде, поэтому возвращаемая строка содержит ровно те байты, которые хранятся в ресурсе.
* `resource_isdir(package_or_requirement, resource_name)` - Является ли именованный ресурс каталогом? Возвращает True или False соответственно.
* `resource_listdir(package_or_requirement, resource_name)` - Список содержимого указанного каталога ресурсов, как и `os.listdir`, за исключением того, что он работает, даже если ресурс находится в zip-файле.

Обратите внимание, что только `resources_exists()` и `resources_isdir()` нечувствительны к типу ресурса. Вы не можете использовать `resources_listdir()` для файлового ресурса, а также вы не можете использовать `resources_string()` или `resources_stream()` для ресурсов каталога. Использование неподходящего метода для типа ресурса может привести к исключению или неопределенному поведению, в зависимости от используемой платформы и формата распространения.

#### Извлечение ресурса

* `resource_filename(package_or_requirement, resource_name)` - Иногда недостаточно получить доступ к ресурсу в строковой или потоковой форме, и необходимо истинное имя файла файловой системы. В таких случаях вы можете использовать этот метод (или функцию уровня модуля) для получения имени файла для ресурса. Если ресурс находится в архивном дистрибутиве (например, в заархивированном egg), он будет извлечен в каталог кеша, и будет возвращено имя файла в кеше. Если именованный ресурс является каталогом, то все ресурсы внутри этого каталога (включая подкаталоги) также извлекаются. Если именованный ресурс является расширением C или «жадным ресурсом» (подробности см. в документации по setuptools), то все расширения C и жадные ресурсы извлекаются одновременно.

Архивированные ресурсы извлекаются в место кэша, которым можно управлять следующими двумя методами:

* `set_extraction_path(path)` - При необходимости укажите базовый путь, по которому будут извлекаться ресурсы. Если вы не вызываете эту процедуру до того, как будут выполнены какие-либо извлечения, путь по умолчанию будет соответствовать возвращаемому значению `get_default_cache()`. (Она основана на переменной среды PYTHON\_EGG\_CACHE с различными резервными вариантами, зависящими от платформы. Более подробную информацию см. в документации по этой процедуре.) Ресурсы извлекаются в подкаталоги этого пути на основе информации, предоставленной поставщиком ресурсов. Вы можете установить временный каталог, но тогда вам придется вызвать `cleanup_resources()`, чтобы удалить извлеченные файлы после завершения. Нет никакой гарантии, что `cleanup_resources()` сможет удалить все извлеченные файлы. (Например, в Windows вы не можете отменить связь с файлами `.pyd` или `.dll`, которые все еще используются.) Обратите внимание, что вы не можете изменить путь извлечения для данного менеджера ресурсов после извлечения ресурсов, если только вы сначала не вызовете `cleanup_resources ()`.
* `cleanup_resources(force=False)` - Удаляет все извлеченные файлы ресурсов и каталоги, вернув список имен файлов и каталогов, которые не удалось успешно удалить. Эта функция не имеет никакой защиты от параллелизма, поэтому ее обычно следует вызывать только в том случае, если путь извлечения является временным каталогом, эксклюзивным для одного процесса. Этот метод не вызывается автоматически; вы должны вызвать ее явно или зарегистрировать как функцию atexit, если хотите обеспечить очистку временного каталога, используемого для извлечения.

#### Интерфейс "Provider"

Если вы реализуете IResourceProvider и/или IMetadataProvider для нового формата архива дистрибутива, вам может потребоваться использовать следующие методы IResourceManager для координации извлечения ресурсов в файловую систему. Однако если вы не реализуете формат архива, вам нет необходимости использовать эти методы. В отличие от других методов, перечисленных выше, они недоступны как функции верхнего уровня, привязанные к глобальному ResourceManager; поэтому для их использования вам необходим явный экземпляр ResourceManager.

* `get_cache_path(archive_name, names=())` - Возвращает абсолютное местоположение в кеше для archive\_name и names. Родительский каталог полученного пути будет создан, если он еще не существует. archive\_name должно быть базовым именем файла, включающего egg (которое может не совпадать с именем вложенного zip-файла!), включая его расширение `".egg"`. имена, если они предусмотрены, должны представлять собой последовательность частей имени пути «под» местом извлечения egg. Этот метод следует вызывать только поставщикам ресурсов, которым необходимо получить местоположение извлечения, и только для имен, которые они собираются извлечь, поскольку он отслеживает сгенерированные имена для возможной последующей очистки.
* `extraction_error()` - Вызывает ExtractionError, описывающее активное исключение как мешающее процессу извлечения. Вам следует вызвать это, если вы столкнулись с какими-либо ошибками ОС при извлечении файла в путь к кэшу; он отформатирует для вас исключение операционной системы и добавит в экземпляр ExtractionError другую информацию, которая может понадобиться программам, которые хотят самостоятельно обернуть или обработать ошибки извлечения.
* `postprocess(tempname, filename)` - Выполняет любую постобработку tempname для конкретной платформы. Поставщики ресурсов должны вызывать этот метод ТОЛЬКО после успешного извлечения сжатого ресурса. Они НЕ должны вызывать его для ресурсов, которые уже находятся в файловой системе. tempname — это текущее (временное) имя файла, а filename — это имя, в которое он будет переименован вызывающей стороной после возврата из этой подпрограммы.

### Metadata API

API метаданных используется для доступа к ресурсам метаданных, включенным в подключаемый дистрибутив. Ресурсы метаданных — это виртуальные файлы или каталоги, содержащие информацию о дистрибутиве, например, которые могут использоваться расширяемым приложением или платформой для подключения «плагинов». Как и другие виды ресурсов, имена ресурсов метаданных разделяются `/` и не должны содержать `..` или начинаться с `/`. Не следует использовать процедуры os.path для управления путями к ресурсам.

API метаданных предоставляется объектами, реализующими интерфейсы IMetadataProvider или IResourceProvider. Объекты распространения реализуют этот интерфейс, как и объекты, возвращаемые функцией `get_provider()`:

* `get_provider(package_or_requirement)` - Если указано имя пакета, возвращает IResourceProvider для пакета. Если указано Requirment, разрешите его, вернув Distribution из текущего рабочего набора (при необходимости выполнив поиск в текущей Environment и добавив вновь найденный Distribution в рабочий набор). Если указанный пакет невозможно импортировать или Requirment не может быть удовлетворено, возникает исключение.

{% hint style="info" %}
если вы используете имя пакета, а не Requirement, возвращаемый объект может не быть подключаемым дистрибутивом, в зависимости от метода установки пакета. В частности, пакеты "development" и пакеты «одной версии, управляемые извне» не имеют возможности сопоставить имя пакета с метаданными соответствующего проекта. Не пишите код, который передает имя пакета в функцию `get_provider()`, а затем пытается получить метаданные проекта из возвращенного объекта. Может показаться, что он работает, когда указанный пакет находится в файле или каталоге `.egg`, но в других сценариях установки он не будет работать. Если вам нужны метаданные проекта, вам нужно запросить _**проект**_, а не пакет.
{% endhint %}

#### Методы IMetadataProvider

Методы, предоставляемые объектами (такими как экземпляры Distribution), которые реализуют интерфейсы IMetadataProvider или IResourceProvider:

* `has_metadata(name)` - Существует ли указанный ресурс метаданных?
* `metadata_isdir(name)` - Является ли названный ресурс метаданных каталогом?
* `metadata_listdir(name)` - Список имен метаданных в каталоге (например, `os.listdir()`)
* `get_metadata(name)` - Возвращает именованный ресурс метаданных в виде строки. Данные считываются в двоичном режиме; т.е. возвращаются точные байты файла ресурсов.
* `get_metadata_lines(name)` - Выдает именованный ресурс метаданных в виде списка непустых строк без комментариев. Это сокращение от вызова `yield_lines(provider.get_metadata(name))`. Дополнительную информацию о распознаваемом синтаксисе см. в разделе, посвященном [yield\_lines()](obnaruzhenie-paketa-i-dostup-k-resursam-s-pkg\_resources.md#utility-sintaksicheskogo-analiza) ниже.
* `run_script(script_name, namespace)` - Выполняет указанный сценарий в предоставленном словаре пространства имен. Вызывает ResolutionError, если в каталоге метаданных scripts нет сценария с таким именем. namespace имен должно быть словарем Python, обычно словарем модуля, если скрипт запускается как модуль.

### Поддержка пользовательских импортеров

#### IResourceProvider

### Служебные функции

#### Утилиты синтаксического анализа

#### Утилиты платформы
