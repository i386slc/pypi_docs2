# Точки входа (entry poynts)

Точки входа — это тип метаданных, которые могут предоставляться пакетами при установке. Это очень полезная функция экосистемы Python, которая особенно удобна в двух сценариях:

1. Пакет хотел бы предоставить команды для запуска на терминале. Эта функциональность известна как **консольные** **сценарии**. Команда также может открыть графический интерфейс, и в этом случае она называется **сценарием графического интерфейса**. Примером консольного сценария является сценарий, предоставляемый пакетом **pip**, который позволяет вам запускать в терминале такие команды, как `pip install`.
2. Пакет хотел бы включить настройку своих функций с помощью **плагинов**. Например, тестовая среда **pytest** позволяет выполнять настройку через точку входа **pytest11**, а инструмент подсветки синтаксиса **pygments** позволяет указывать дополнительные стили с помощью точки входа `pygments.styles`.

## Консольные скрипты

Начнем с консольных скриптов. Сначала рассмотрим пример без точек входа. Представьте себе пакет, определенный следующим образом:

```
project_root_directory
├── pyproject.toml        # и/или setup.cfg, setup.py
└── src
    └── timmins
        ├── __init__.py
        └── ...
```

с `__init.py__` как:

```python
def hello_world():
    print("Hello world")
```

Теперь предположим, что мы хотели бы обеспечить какой-то способ выполнения функции `hello_world()` из командной строки. Один из способов сделать это — создать файл `src/timmins/__main__.py`, предоставляющий хук следующим образом:

```python
from . import hello_world

if __name__ == '__main__':
    hello_world()
```

Затем, после установки пакета **timmins**, мы можем вызвать функцию `hello_world()` следующим образом через модуль [runpy](https://docs.python.org/3/library/runpy.html):

```bash
$ python -m timmins
Hello world
```

Вместо этого подхода с использованием `__main__.py` вы также можете создать удобный исполняемый файл CLI, который можно вызывать напрямую без `python -m`. В приведенном выше примере, чтобы создать команду **hello-world**, которая вызывает `timmins.hello_world`, добавьте в свою конфигурацию точку входа сценария консоли:

#### pyproject.toml

```toml
[project.scripts]
hello-world = "timmins:hello_world"
```

#### setup.cfg

```ini
[options.entry_points]
console_scripts =
    hello-world = timmins:hello_world
```

#### setup.py

```python
from setuptools import setup

setup(
    # ...,
    entry_points={
        'console_scripts': [
            'hello-world = timmins:hello_world',
        ]
    }
)
```

После установки пакета пользователь может вызвать эту функцию, просто вызвав **hello-world** в командной строке:

```bash
$ hello-world
Hello world
```

Обратите внимание, что любая функция, используемая в качестве консольного скрипта, например `hello_world()` в этом примере, не должна принимать никаких аргументов. Если ваша функция требует какого-либо ввода от пользователя, вы можете использовать обычные утилиты анализа аргументов командной строки, такие как [argparse](https://docs.python.org/3/library/argparse.html#module-argparse), внутри тела функции для анализа ввода пользователя, переданного через [sys.argv](https://docs.python.org/3/library/sys.html#sys.argv).

Вы могли заметить, что мы использовали специальный синтаксис для указания функции, которая должна быть вызвана консольным сценарием, т. е. мы написали `timmins:hello_world` с двоеточием `:`, разделяя имя пакета и имя функции. Полная спецификация этого синтаксиса обсуждается в [последнем разделе](tochki-vkhoda-entry-poynts.md#sintaksis-tochek-vkhoda) этого документа, и его можно использовать для указания функции, расположенной в любом месте вашего пакета, а не только в `__init__.py`.

## Скрипты графического интерфейса

В дополнение к **console\_scripts**, Setuptools поддерживает **gui\_scripts**, которые запускают приложение с графическим интерфейсом без запуска в окне терминала.

Например, если у нас есть проект с той же структурой каталогов, что и раньше, с файлом `__init__.py`, содержащим следующее:

```python
import PySimpleGUI as sg

def hello_world():
    sg.Window(title="Hello world", layout=[[]], margins=(100, 50)).read()
```

Затем мы можем добавить точку входа GUI-скрипта:

#### pyproject.toml

```toml
[project.gui-scripts]
hello-world = "timmins:hello_world"
```

#### setup.cfg

```ini
[options.entry_points]
gui_scripts =
    hello-world = timmins:hello_world
```

#### setup.py

```python
from setuptools import setup

setup(
    # ...,
    entry_points={
        'gui_scripts': [
            'hello-world = timmins:hello_world',
        ]
    }
)
```

{% hint style="info" %}
Чтобы иметь возможность импортировать **PySimpleGUI**, вам нужно добавить **pysimplegui** в зависимости вашего пакета. Дополнительные сведения см. в разделе [Управление зависимостями в Setuptools](upravlenie-zavisimostyami-v-setuptools.md).
{% endhint %}

Теперь запускаю:

```bash
$ hello-world
```

откроется небольшое окно приложения с заголовком «Hello world».

Обратите внимание, что, как и в случае консольных сценариев, любая функция, используемая в качестве сценария графического интерфейса, не должна принимать никаких аргументов, и любой ввод пользователя может быть проанализирован в теле функции. Сценарии с графическим интерфейсом также используют тот же синтаксис (который будет рассмотрен в [последнем разделе](tochki-vkhoda-entry-poynts.md#sintaksis-tochek-vkhoda)) для указания вызываемой функции.

{% hint style="info" %}
Разница между **console\_scripts** и **gui\_scripts** влияет только на системы Windows. \[1] **console\_scripts** завернуты в исполняемый файл консоли, поэтому они присоединены к консоли и могут использовать `sys.stdin`, `sys.stdout` и `sys.stderr` для ввода и вывода. **gui\_scripts** завернуты в исполняемый файл с графическим интерфейсом, поэтому их можно запускать без консоли, но они не могут использовать стандартные потоки, если код приложения не перенаправляет их. Другие платформы не имеют такого различия.
{% endhint %}

{% hint style="info" %}
Сценарии консоли и графического интерфейса работают, потому что за кулисами установщики, такие как [pip](https://pypi.org/project/pip), создают сценарии-оболочки вокруг вызываемых функций. Например, точка входа **hello-world** в двух приведенных выше примерах создаст команду **hello-world**, запускающую такой скрипт: \[1]

```python
import sys
from timmins import hello_world
sys.exit(hello_world())
```
{% endhint %}

## Рекламное поведение

Сценарии консоли/графического пользовательского интерфейса — это одно из применений более общей концепции точек входа. Точки входа в более общем смысле позволяют упаковщику объявлять поведение для обнаружения другими библиотеками и приложениями. Эта функция обеспечивает функциональность, подобную "plug-in", когда одна библиотека запрашивает точки входа, а любое количество других библиотек предоставляет эти точки входа.

Хороший пример такого поведения подключаемого модуля можно увидеть в [подключаемых модулях pytest](https://docs.pytest.org/en/latest/writing\_plugins.html), где **pytest** — это тестовая среда, которая позволяет другим библиотекам расширять или изменять свою функциональность через точку входа **pytest11**.

Сценарии консоли/графического интерфейса пользователя работают аналогично, когда библиотеки рекламируют свои команды, а инструменты, такие как **pip**, создают сценарии-оболочки, которые вызывают эти команды.

## Точки входа для плагинов

Давайте рассмотрим простой пример, чтобы понять, как мы можем реализовать точки входа, соответствующие плагинам. Скажем, у нас есть пакет **timmins** со следующей структурой каталогов:

```
timmins
├── pyproject.toml        # и/или setup.cfg, setup.py
└── src
    └── timmins
        └── __init__.py
```

## Синтаксис точек входа
